<?xml version="1.0" encoding="UTF-8"?>
<!-- vim: set noai indentexpr&
-->
<book xml:id="stirmake" xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Scalable true implementation of recursive make (stirmake)</title>
    <author>
      <personname>
        <firstname>Juha-Matti</firstname>
        <surname>Tilli</surname>
      </personname>
    </author>
    <copyright>
      <year>2023-2025</year>
      <holder>Juha-Matti Tilli</holder>
    </copyright>
  </info>
  <part xml:id="part_make">
  <title>Make, a historical tool</title>
  <chapter xml:id="make">
    <title>Make, the de facto build tool</title>

<sect1 xml:id="basics">
<title>Introduction to basics of make</title>

<para>

The first and most well-known build tool is make. Stuart Feldman authored make
in 1976 in Bell Labs. The idea of make is that while build can be done using a
shell script, a shell script executes all build commands uncondionally. In a
small project consisting of a single C language source file, this is not a
problem. However, larger projects can consist of multiple C source files, for
example Linux 6.17-rc7 contains 35778 source files, not counting header files.
If in a large project a small change is made, it should affect only on the code
that is dependent on it. For example, if a C source file is changed, only that
source file should be recompiled and any .a archive, shared library or
executable binary dependent on it should be re-linked.

</para><para>

A simple Makefile could be as follows:
<programlisting>
.PHONY: all
all: myprog
CC=cc
CFLAGS=-O1
myprog: myprog.c
	$(CC) $(CFLAGS) -o $@ $^
</programlisting>

</para><para>

Here $@ refers to the target name, wheras $^ contains all dependencies. Instead of $^, the first dependency can be referred to with $&lt;.

</para><para>

In this case, myprog is re-built only if nonexistent, or if its timestamp is
before the modification timestamp of myprog.c.

</para>

</sect1>
<sect1 xml:id="cleanandmakefiledep">
<title>Cleaning and dependency on Makefile</title>

<para>

A problem immediately appears. The file myprog does not depend on Makefile.
So if CFLAGS is modified, myprog won't be rebuilt. The answer to this generally
is two-fold.

</para><para>

Firstly, a target clean is added to clean everything:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
myprog: myprog.c
	$(CC) $(CFLAGS) -o $@ $^
</programlisting>

</para><para>

Then if CFLAGS is modified, the user can run "make clean" and then "make". This
demonstrates that the all-important "make clean" must be executed very often
with make-based build systems. This also demonstrates that it's all too easy to
forget something from "make clean". For example, in this simple Makefile, if a
new target secondprog is added, it needs to be added to its rule, but also to
"make clean" rule which is often forgotten.

</para><para>

Another possibility is adding dependency to Makefile, but this requires some
changes so that it's not given to CC as an argument:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
myprog: myprog.c Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.c,$^)
</programlisting>

</para><para>

Note that filter is a GNU make extension, and may not be available in other
implementations of make.

</para><para>

However, with both approaches, the "solution" is to clean or re-build
everything if the Makefile is changed. This is a problem in cases where the
Makefile is huge, but only one command to build one target is modified. Both
"solutions" in this case recompile everything, not just the target that had
a change in its command.

</para>

</sect1>
<sect1 xml:id="largerprojects">
<title>Somewhat larger single-directory projects</title>
<para>
In larger projects, it is generally preferred to not compile binary from C
sources directly, but instead create object files that are then linked:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
	rm -f myprog.o mylib.o
myprog: myprog.o mylib.o Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
myprog.o: myprog.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
mylib.o: mylib.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
</programlisting>

</para><para>

Now there are two unclean approaches in this Makefile. First is that the
information about what object files are there is repeated to three locations:
the rule of the object file, the linking rule, and the "make clean" phony rule.
The second is that if there are N object files, the command to build them is
repeated N times. These can be solved with some GNU make extensions:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
</programlisting>

</para><para>

Now the list of object files is specified only once, and the rule to build an
object from a source is common to all object files. Note that already at this
stage, the standard POSIX make is not enough, an GNU extensions have to be
used.

</para>

</sect1>
<sect1 xml:id="headerfile">
<title>Header file dependencies</title>

<para>

However, this more complex Makefile suffers from the fact that compiling
myprog.c into myprog.o most likely requires inclusion of a header file,
mylib.h. So myprog.o depends on mylib.h. This can be specified as an additional
dependency in the Makefile:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
myprog.o: mylib.h
</programlisting>

</para><para>

But however, this approach does not scale. Every time a C file is modified and
a new header file is added, it must be documented in the Makefile. Worse, a
header file can include other headers, and all of them should be documented
in the Makefile. Clearly, something better is needed.

</para><para>

Fortunately, most C compilers support outputting dependencies, which can be
imported:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS) $(DEPS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -o $@ $&lt;
-include $(DEPS)
</programlisting>

</para><para>

So the C compiler then creates the files myprog.d mylib.d that both myprog.o
and mylib.o depend on mylib.h. This is fully automatic. Before a build has been
made, the .d dependency files don't exist, but then everything must be
initially compiled anyway. In this case, -MM means omit system header files.
With -M only, system header file dependencies would be stored in the .d files.

</para><para>

Also notice that instead of include, you use -include. This is because the
dependency files don't exist the first time make is run.

</para><para>

Is the Makefile now good enough? No, because if mylib.h is renamed to
mylibpublic.h, then the .d files contain reference to the old mylib.h and make
notices it can't find that file. So an empty phony rule is needed to affect
make in such a manner that it doesn't exit when finding a reference to a
nonexistent header file. Fortunately, the -M option has -MP which adds the
phony rules and now "make clean" is not necessary if a header is renamed:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS) $(DEPS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -o $@ $&lt;
-include $(DEPS)
</programlisting>

</para><para>

However, this is not all that needs to be done. The .d files aren't updated
if a header file changes, only the .o files are updated. Fortunately, most
C compilers have an option to solve this: -MT:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS) $(DEPS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
-include $(DEPS)
</programlisting>

</para><para>

Now the .d files finally work just fine. However, there were a lot of
difficulties in the road to make the ultimate dependency file mechanism.

</para>
</sect1>

  </chapter>
  <chapter xml:id="makemultidirproject">
    <title>Where make fails, multi-directory projects</title>
    <sect1 xml:id="makedirsep">
      <title>Make with directory separators</title>

<para>

Let's consider you have a directory prog with file prog.c, and a directory lib
with files lib1.c and lib2.c, creating a static library file liblib.a. Then the
Makefile needs to create liblib.a and link it into prog. How to do this in
make?

</para><para>

Make does not have support for multiple nested directories, but make does
accept slash in file names. So let's create a top-level Makefile that compiles
stuff in directories prog and lib:
<programlisting>
.PHONY: all clean
all: prog/prog lib/liblib.a
CC=cc
CFLAGS=-O1
OBJLIB=lib/lib1.o lib/lib2.o
OBJPROG=prog/prog.o
OBJALL=$(OBJLIB) $(OBJPROG)
DEPALL=$(patsubst %.o,%.d,$(OBJALL))
clean:
	rm -f prog/prog lib/liblib.a
	rm -f $(OBJALL) $(DEPALL)
prog/prog: prog/prog.o lib/liblib.a Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^) $(filter %.a,$^)
lib/liblib.a: $(OBJLIB) Makefile
	rm -f $@
	ar rvs $@ $(filter %.o,$^)
$(OBJALL): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPALL): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
-include $(DEPALL)
</programlisting>

</para><para>

Note that in this program listing, the argument -o $@ to make is necessary.
Without it, the C compile is executed in the top-level directory, and the
output file would be stored into this top-level directory, not in the
subdirectory where the source file is.

</para><para>

This approach works but suffers from the drawback that in a project of 3000
subdirectories like in Linux kernel, the one and only top-level Makefile would
grow into a huge monster which makes its maintenance practically impossible.

</para>
    </sect1>
    <sect1 xml:id="makefileperdir">
      <title>Another approach: Makefile per directory</title>
      <sect2 xml:id="recursivemaketest">
        <title>Let's try recursive make</title>
      </sect2>
      <sect2 xml:id="nocommonnamespace">
        <title>Fixing no common namespace: include file</title>
      </sect2>
      <sect2 xml:id="dangersofseparating">
        <title>Drawbacks and dangers of separating build to multiple DAGs</title>
        <!-- top-level directory must have module-level dependencies -->
        <!-- parallel build hard: explain the jobserver hack -->
        <!-- "Recursive Make Considered Harmful" -->
        <!-- so let's try another approach, inclusive make -->
      </sect2>
    </sect1>
    <sect1 xml:id="inclusivemake">
      <title>Another approach: one Makefile, module.mk per directory</title>
      <!-- refer to makedirsep: commands are executed in subdirectory -->
      <!-- one common namespace -->
      <!-- dangers of one common namespace when including sub-projects: this is where even die-hard inclusive make proponents switch to recursion -->
    </sect1>
    <sect1 xml:id="parallelmake">
      <title>Parallel make, jobserver and lack of multiple targets</title>
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_stirmakeintro">
  <title>Stirmake, a modern tool</title>
  <chapter xml:id="stirmakeintro">
    <title>Introducing stirmake</title>
    <sect1 xml:id="stirmakeinstall">
      <title>Compiling and installing stirmake</title>

<para>
Firstly, before stirmake can be used, flex, byacc and git need to be installed.
Flex is a very widely used tool, the most common implementation of lex today,
so its installation shouldn't be a problem, as most Unix-like operating systems
have an easy way to install it. Similarly, git is probably the most popular
version control system so installing it shouldn't be a problem. On the other
hand, byacc may cause problems in some environments. At least RedHat and
Debian-based systems such as Ubuntu contain byacc in their repositories. In
stirmake, bison was considered but rejected due to the GPL license, which byacc
does not suffer from. Fortunately, byacc should be easy to compile from sources
if the operating system does not have a ready-made package for it.

</para><para>

You also need GNU make to bootstrap stirmake, and the essential build tools
like C compiler and linker.

</para><para>

On RedHat, you would install the dependencies as follows:
<programlisting>
yum install flex byacc git
yum groupinstall 'Development Tools'
</programlisting>

</para><para>

On Debian and Ubuntu, it works as follows:
<programlisting>
apt install flex byacc git build-essential
</programlisting>

</para><para>

Now when dependencies have been installed, it's time to recursively clone and
install stirmake:
<programlisting>
git clone --recursive https://github.com/Aalto5G/stirmake
cd stirmake/stirc
make
./install.sh
</programlisting>

</para><para>

This installs stirmake to your ~/.local/bin that needs to be in the path. If
the directory did not exist, it probably isn't in the path and you may need to
re-log-in. Globally installing stirmake to /usr/local would happen as follows,
assuming it's already cloned:
<programlisting>
cd stirmake/stirc
make
sudo ./install.sh /usr/local
sudo mandb
</programlisting>

</para><para>

After it has been installed, try it:
<programlisting>
mkdir stirmaketry
cd stirmaketry
stirmake -a
smka
smkp
smkt
</programlisting>

</para><para>

All of the commands to invoke stirmake should print something like this:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/stirmaketry
stirmake: *** Stirfile not found. Exiting.
</programlisting>

</para><para>

They should also leave a .stir.db file containing just two lines out of which
the second is empty:
<programlisting>
@v2@

</programlisting>

</para><para>

Stirmake has been designed to work on POSIX systems but sometimes non-POSIX
functions are needed. For example, stirmake heavily benefits from availability
of madvise but does not require it. But what stirmake requires is the
possibility to map anonymous memory, whether it's MAP_ANON or MAP_ANONYMOUS
argument to mmap, or mmap from an open file /dev/zero. Also obsolete POSIX
setitimer is needed since the newer equivalents timer_settime etc. may not be
available on all systems like OpenBSD. The new POSIX utimensat heavily benefits
stirmake, but it can work with utimes if utimensat is not present. What is not
present in POSIX is getloadavg, but all the important operating systems like
BSDs, Linux, MacOS X and Solaris have it. Stirmake can work without it, but it
disables the functionality to reduce parallelism at times of increased load.

</para>

    </sect1>
    <sect1 xml:id="helloworld">
      <title>Compiling hello world</title>

<para>

Always "hello world" is the program that is written in any programming
language. Similarly, it must be easy to compile "hello world", a single source
file, in any build system.

</para><para>

First, let's create the .c source file hello.c:
<programlisting>
#include %lt;stdio.h%gt;
int main(int argc, char **argv)
{
  printf("Hello, world!\n");
  return 0;
}
</programlisting>

</para><para>

Then we can create the Stirfile to build it:
<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	["cc", "-o", $@, $&lt;]
</programlisting>

</para><para>

To actually build everything in this stirfile, type "smka".

</para><para>

Note the @-tabulator at the beginning of the command line. Similar to make,
tabulator must be present before the command. However, in this case, the @
specifier is used to bypass shell and use direct execution of the compiler.

</para><para>

If shell is needed, there are two options. First is to invoke sh with -c
argument:
<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	["sh", "-c", "cc -o " . $@ . " " . $&lt;]
</programlisting>

</para><para>

The second is to invoke it the same way as with make, omitting the @ character
before tabulator:
<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
	cc -o $@ $&lt;
</programlisting>

</para><para>

Both of these ways to invoke the shell are equal, as evidenced by the identical
output:
<programlisting>
stirmake: Using directory /home/juhis/smdb/shell
[., hello] sh -c cc -o hello hello.c
</programlisting>

</para><para>

Note that the rule 'all' is phony, but the rule 'hello' is not. A rule that
is not phony must create its target. If the target was not created, the rule
should probably be marked a @phonyrule. Standard GNU make does not warn if
a rule that is non-phony does not create its target. But stirmake does warn:
<programlisting>
@toplevel
@strict
'all': 'hello'
'hello': 'hello.c'
@	["cc", "-o", $@, $&lt;]
</programlisting>

</para><para>

This results in:
<programlisting>
stirmake: Using directory /home/juhis/smdb/shell
[., hello] cc -o hello hello.c
stirmake: *** Target all was not created by rule.
stirmake: *** Hint: use @phonyrule for phony rules.
stirmake: *** Hint: use @mayberule for rules that may or may not update target.
stirmake: *** Hint: use @rectgtrule for rules that have targets inside @recdep.
stirmake: *** Target all was not created by rule. Exiting.
</programlisting>

</para><para>

All of the rules here were marked @strict. @strict means that targets and
sources must be strings, using single or double quotes around them. If @strict
is not used, you may omit the quotes. However, this is not recommended, since
after @strict has been removed, the token 4/2 is not a mathematical expression
equal to 2, but it's a file 2 in directory 4. The reason here being that
maximum munch tokenization is used, and 4/2 is longer than 4, so the lexer goes
on to include more stuff for the token. In non-@strict mode, to calculate 4
divided by 2, you can add spaces or parentheses: 4 / 2 or (4)/(2).

</para><para>

Note that the @-tabulator syntax has a different way to specify variables than
the tabulator syntax. The @-tabulator syntax parses an arbitrary Amyplan
expression, which should create an array. This means for example variable
CC can be referred to by $CC. However, the tabulator-only syntax
requires $(CC). So you can have:
<programlisting>
@toplevel
@strict
$CC = "cc"
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	[$CC, "-o", $@, $&lt;]
</programlisting>

</para><para>

But with tabulator, this doesn't work:
<programlisting>
@toplevel
@strict
$CC = "cc"
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
	$CC -o $@ $&lt;
</programlisting>

</para><para>

But you must do this instead:
<programlisting>
@toplevel
@strict
$CC = "cc"
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
	$(CC) -o $@ $&lt;
</programlisting>

</para><para>

However, the $(CC) syntax works outside a tabulator line too:
<programlisting>
@toplevel
@strict
$(CC) = "cc"
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	[$(CC), "-o", $@, $&lt;]
</programlisting>

</para>

    </sect1>
    <sect1 xml:id="modularhellolib">
      <title>Modular hello from library</title>
<para>

The previous section demonstrated how to build a simple project with one
directory using stirmake. However, complex projects have numerous directories
and may have several binaries and several static libraries. We shall
emulate such a project by a modular "hello world" application where the
program invokes a function from a static library.

</para><para>

Let's create the top-level Stirfile first:
<programlisting>
@toplevel
@strict
$CC = "cc"
$RM = "rm"
$AR = "ar"
$CFLAGS = ["-Wall", "-O3"]
@phonyrule: 'all': 'lib/all' 'prog/all'
@dirinclude "lib"
@dirinclude "prog"
</programlisting>

Then let's create a directory lib with hello.c:
<programlisting>
#include "hello.h"
#include &lt;stdio.h&gt;
void hello(void)
{
  printf("Hello world\n");
}
</programlisting>
...and hello.h:
<programlisting>
#ifndef _HELLO_H_
#define _HELLO_H_

void hello(void);

#endif
</programlisting>
...and Stirfile:
<programlisting>
@subfile
@strict
$OBJS=["hello.o"]
$DEPS=@sufsuball($OBJS, ".o", ".d")

@phonyrule: 'all': 'libhello.a'

'libhello.a': $OBJS
@	[$RM, "-f", $@]
@	[$AR, "rvs", $@, @@suffilter($^, ".o")]

@patrule: $OBJS: '%.o': '%.c' '%.d'
@	[$CC, @$CFLAGS, "-c", "-o", $@, $&lt;]
@patrule: $DEPS: '%.d': '%.c'
@	[$CC, @$CFLAGS, "-MM", "-o", $@, $&lt;]

@cdepincludes @autophony @autotarget @ignore $DEPS
</programlisting>
...which contains the @-operator which is used to include a whole array into
another array. For example, [$CC, $CFLAGS] would not be an array of strings
since $CFLAGS is an array already. But [$CC, @$CFLAGS] is an array of strings
due to the @-operator. The same operator is used in [$AR, "rvs", $@,
@@suffilter($^, ".o")] where having only [$AR, "rvs", $@, @suffilter($^, ".o")]
would not be an array of strings. Also @cdepincludes @autophony @autotarget
@ignore was used to include C language header dependencies. Usually all of
@autophony (add phony rule for each header), @autotarget (add target file.d in
addition to file.o) and @ignore (don't stop if some dependency file doesn't
exist yet) are used together.

</para><para>
Then let's create a directory prog with prog.c:
<programlisting>
#include "hello.h"
int main(int argc, char **argv)
{
  hello();
}
</programlisting>
...and Stirfile:
<programlisting>
@subfile
@strict
$OBJS=["prog.o"]
$DEPS=@sufsuball($OBJS, ".o", ".d")
$CFLAGS += ["-I../lib"]

@phonyrule: 'all': 'prog'

@distrule: 'prog': $OBJS '../lib/libhello.a'
@	[$CC, @$CFLAGS, "-o", $@, @@suffilter($^, ".o"), @@suffilter($+, ".a")]

@patrule: $OBJS: '%.o': '%.c' '%.d'
@	[$CC, @$CFLAGS, "-c", "-o", $@, $&lt;]
@patrule: $DEPS: '%.d': '%.c'
@	[$CC, @$CFLAGS, "-MM", "-o", $@, $&lt;]

@cdepincludes @autophony @autotarget @ignore $DEPS
</programlisting>
...which assigns to $CFLAGS in a manner that is visible only in this subdirectory. The other subdirectory "lib" does not have this modification to $CFLAGS. However, if the "prog" directory contained a subdirectory "prog/proghelpers", with its own Stirfile, then proghelpers would see this modification made to $CFLAGS in prog/Stirfile. This fully working nested recursive scoping is the main feature of Stirmake, making it better than GNU make.

</para><para>

Then several operations can be done. To fully clean the full directory
structure, use the command:
<programlisting>
smka -bc
</programlisting>
...which works in any directory, top-level directory or either of the two
subdirectories. Here "-b" means "clean distributable binaries" (marked with
@distrule) and "-c" means "clean everything else than distributable binaries".
If you want to clean only the subdirectory lib, use:
<programlisting>
cd lib
smkt -bc
</programlisting>

</para><para>

Another operation is building the structure. For example, the following command
works in any directory, top-level or subdirectory, as long as the directory
contains a Stirfile:
<programlisting>
smka
</programlisting>
...but another equivalent option would be:
<programlisting>
cd prog
smkt ../all
</programlisting>
...here "smka" means "stirmake all" and "smkt" means "stirmake this directory".
</para><para>

The power of stirmake is evident by running:
<programlisting>
smka -bc
cd prog
smkt
</programlisting>
...which builds all dependencies of the prog directory too, but nothing else
above the "prog" directory. With recursive make, this would not work:
<programlisting>
make clean
cd prog
make
</programlisting>
...since prog depends on lib, and the only way to build lib would be to invoke
"make" in the top-level directory.

</para>
    </sect1>
    <sect1 xml:id="environmentandconf">
      <title>Environment and configuration commands</title>
      <!-- getenv, chomp, strwordlist, shell-assign, shell-shell-assign -->
      <!-- $PYTHON_CFLAGS ``= ["python3-config", "-"."-includes"] -->
    </sect1>
    <sect1 xml:id="multiprocessing">
      <title>Multiprocessor machines</title>
      <!-- -ja, -la, etc -->
      <!-- need to specify all targets if there are multiple -->
      <!-- make does not support specifying all targets -->
    </sect1>
    <sect1 xml:id="tracingdebugging">
      <title>Tracing and debugging</title>
      <!-- tracing -->
      <!-- debugging -->
    </sect1>
  </chapter>
  <chapter xml:id="variabledatatypefunction">
    <title>Variables, data types and functions</title>
    <sect1 xml:id="dump">
      <title>Dump: hello from stirmake</title>

<para>

One of the most common tools you need all the time is @dump. It prints its argument in a format that works for all of the data types.

</para><para>

As an example, run this Stirfile:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@call @dump("Hello world")
@call @dump(123)
@call @dump(456.78)
@call @dump(@nil)
@call @dump(["foo", 5])
@call @dump({"bar": {"baz": [567, 89]}})
</programlisting>

</para><para>

It should print:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/SUBDIR
"Hello world"
123
456.77999999999997272
null
["foo", 5]
{"bar": {"baz": [567, 89]}}
stirmake: Nothing to be done.
</programlisting>

</para><para>

Note that dump is a debugging tool. If you want to print strings without the
quotation marks, you need some other tool. But a clear benefit of dump is that
it works for all data types.

</para><para>

Also note the @call specifiers before @dump. Every time an Amyplan statement
is run, without its output being saved to a variable, at top level (outside of
Amyplan functions), @call is needed. Amyplan has a distinction between
expressions and statements, and @dump is a statement. An alternative could be
calling @dump inside a function, in which case @call is not used:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $AMYPLANFUN()
  @dump("Hello world")
  @dump(123)
  @dump(456.78)
  @dump(@nil)
  @dump(["foo", 5])
  @dump({"bar": {"baz": [567, 89]}})
@endfunction
@call $AMYPLANFUN()
</programlisting>

</para><para>

Note that since @dump is a statement instead of an expression, this does not
work:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$DISCARD=@dump("Hello world")
$DISCARD=@dump(123)
$DISCARD=@dump(456.78)
$DISCARD=@dump(@nil)
$DISCARD=@dump(["foo", 5])
$DISCARD=@dump({"bar": {"baz": [567, 89]}})
@call @dump($DISCARD)
</programlisting>

</para>

    </sect1>
    <sect1 xml:id="variables">
      <title>Defining variables</title>

<para>

Variables can be defined outside of functions with the following syntax:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR ?= @nil
@call @dump($MYVAR)
$MYVAR = [2, "fof", {"bar": {"baz": [567, 89]}}]
$MYVAR += [12345, 54321]
$MYVAR ?= @nil
@call @dump($MYVAR)
</programlisting>

</para><para>

Note the several assignment operators here. ?= is conditional assigment,
assign only if the variable is nonexistent. = is the normal assigment
operator. For lists, += allows appending multiple elements to the list.

</para><para>

Generally, it is recommended that you define variables $CC and $CFLAGS if you
compile C code. Both of them ideally should be arrays, since some Makefiles in
fact assign some of the arguments to $CC into $CC and not into $CFLAGS. Also
defining variables for sources and targets as arrays is typical.

</para><para>

Inside functions, accessing and assigning into global variables requires
scope information, lexical or dynamic. An example of lexical scoping:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR ?= @nil
@function $MYFUN()
  @L$MYVAR = 5
@endfunction
@function $MYFUN2()
  @locvar $MYVAR=321
  @dump(@L$MYVAR)
  @dump($MYVAR)
@endfunction
@call $MYFUN()
@call $MYFUN2()
</programlisting>

</para><para>

Lexical scoping @L means that the function acceses the scope in which it was
defined. Dynamic scoping with @D would mean the function accesses the scope in
which it was called. Local variables are accessed without scope specifiers.  If
a variale access happens inside a function, it is a local variable as default.
Even function calls need scope specifiers:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR ?= @nil
@function $MYFUN()
  @L$MYVAR = 5
@endfunction
@function $MYFUN2()
  @locvar $MYVAR=321
  @L$MYFUN()
  @dump(@L$MYVAR)
  @dump($MYVAR)
@endfunction
@call $MYFUN2()
</programlisting>

</para><para>

Note that local variables need to be defined at the start of the function.
If you need a local variable set in the middle of the function, you need to
define it at the start, but you can assign @nil into it if you don't have
anything better to assign.

</para>
    </sect1>
    <sect1 xml:id="specvar">
      <title>Special variables</title>

<para>

There are five special variables: $@, $&lt;, $^, $+ and $|.

</para><para>

Out of these, $@, $lt; and $^ are the most often used. $@ is the name of the
first target. $&lt; is the name of the first source. $^ is the names of all
sources, with duplicates removed. $+ is the same as $^, but duplicate source
files are repeated in the exact same order, which may be useful sometimes for
linking static libraries that may have circular dependencies. $| is the names
of all order-only dependencies.

</para><para>

Out of these, $@ and$&lt; are strings and the others are arrays of strings.

</para>

    </sect1>
    <sect1 xml:id="datatypes">
      <title>Data types, finally we can have spaces in filenames!</title>

<para>

As mentioned already, stirmake supports strings and arrays. This is a
difference with make since make supports only strings, and arrays are emulated
by space-delimited strings, which means a filename cannot contain spaces.

</para><para>

Stirmake, via its programming language Amyplan and bytecode engine abce
supports the following data types:

<itemizedlist mark="bullet">
<listitem><para>@nil</para></listitem>
<listitem><para>Boolean: @false or @true</para></listitem>
<listitem><para>Number: IEEE double precision floating point, can contain both integers and floating-point numbers, all 32-bit integers can be exactly specified</para></listitem>
<listitem><para>String: an immutable sequence of 8-bit characters, with Unicode as UTF-8 if used</para></listitem>
<listitem><para>Packet buffer: a mutable sequence of bytes, can be converted from/to strings, contents can be modified, length can be modified</para></listitem>
<listitem><para>Array: a mutable sequence of any objects of any types</para></listitem>
<listitem><para>Tree: a mapping from immutable strings to any objects of any type. Note that numbers cannot be used as keys, but numbers can be converted to strings which can be used as keys.</para></listitem>
<listitem><para>I/O streams: a reference to a file which can be use to read and write data</para></listitem>
<listitem><para>Functions, which contain reference to the lexical scope, and which may be called with the correct number of arguments</para></listitem>
<listitem><para>Several internal data types not exposed to the programmer</para></listitem>
</itemizedlist>

</para><para>

The @type expression can be used to obtain the type of a variable, but as it is
a number that doesn't document itself, you should use @type of an example object
against which the type of the object is compared:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR = @nil
@call @dump(@type($MYVAR) == @type(@nil))
@call @dump(@type($MYVAR) == @type(@false))
$MYVAR = 543.21
@call @dump(@type($MYVAR) == @type(123))
@call @dump(@type($MYVAR) == @type("foo"))
$MYVAR = @tostring($MYVAR)
@call @dump(@type($MYVAR) == @type("foo"))
$MYVAR = @tonumber($MYVAR)
@call @dump(@type($MYVAR) == @type(123))
$MYVAR = @tostring($MYVAR)
@call @dump(@type($MYVAR) == @type("foo"))
@call @dump(@type($MYVAR) == @type(@pbnew()))
$MYVAR = @str2pb($MYVAR)
@call @dump(@type($MYVAR) == @type("foo"))
@call @dump(@type($MYVAR) == @type(@pbnew()))
$MYVAR = @pb2str($MYVAR,0,$MYVAR{@})
@call @dump(@type($MYVAR) == @type("foo"))
@call @dump(@type($MYVAR) == @type(@pbnew()))
$MYVAR = [1,2,3]
@call @dump(@type($MYVAR) == @type([]))
@call @dump(@type($MYVAR) == @type({}))
</programlisting>

</para><para>

Note the @tostring and @tonumber operations which can be used to convert
between strings and numbers, and the @str2pb and @pb2str operations which can
be used to convert between strings and packet buffers. The @pb2str operation
requires starting index (0-based starts from 0) and length of slice to take
from the packet buffer. The @str2pb always takes the entire string, but <link
linkend="string">strings can be sliced with @strsub</link> if needed, and then
converted to a packet buffer with @str2pb of the sliced string.

</para>

    </sect1>
    <sect1 xml:id="conditionals">
      <title>Conditionals</title>
      <!-- normal conditionals -->
      <!-- stirmake version conditional -->
    </sect1>
    <sect1 xml:id="loops">
      <title>Loops</title>
      <!-- while, for, once, break, continue, break N, continue N -->
    </sect1>
    <sect1 xml:id="string">
      <title>String</title>
      <!-- common operations -->
      <!-- chomp -->
      <!-- strstr, strrep, strlistjoin, strappend, strstrip -->
      <!-- strsub, strgsub, strset, strword, strwordcnt, strwordlist -->
      <!-- strcmp, strreverse, strupper, strlower, strfromchr -->
      <!-- string append -->
      <!-- tostring, tonumber -->
    </sect1>
    <sect1 xml:id="array">
      <title>Array</title>
      <!-- common operations -->
      <!-- list splice -->
      <!-- append -->
      <!-- appendlist -->
      <!-- array append assignment top-level only -->
    </sect1>
    <sect1 xml:id="simpletypes">
      <title>Simple data types: number, boolean, nil</title>
<para>

The simplest data type that Stirmake supports is nil, which can contain just
one variable: @nil. To compare if something is @nil, you need to get the @type
of the object, since two equal signs are meant for numeric comparison and @nil
is not a number. However, its type is a number. Checking for @nil-ness is as
follows:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $CHECKNIL()
  @locvar $isnil = @nil
  @locvar $notnil = "nil"
  @if(@type($isnil) == @type(@nil))
  @dump("Is nil 1")
  @endif
  @if(@type($notnil) == @type(@nil))
  @dump("Is nil 2")
  @endif
@endfunction
@call $CHECKNIL()
</programlisting>

</para><para>

Booleans can have two values: @false and @true. Every comparison operator
returns a boolean. Booleans are used in @if statements as follows:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $BOOLFN()
  @locvar $isnil = @nil
  @locvar $bool = (@type($isnil) == @type(@nil))
  @if($bool)
  @dump("Boolean is true")
  @endif
@endfunction
@call $BOOLFN()
</programlisting>

</para><para>

Also, the loops @while and @for use booleans to decide whether to continue.
With booleans, you can use the &amp;&amp;, || and ! operators for logical and,
logical or and not, respectively:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $BOOLOP()
  @locvar $isnil = @nil
  @locvar $bool = !(@true &amp;&amp; (@false || @true))
  @if($bool)
  @dump("Boolean is true")
  @else
  @dump("Boolean is false")
  @endif
@endfunction
@call $BOOLOP()
</programlisting>

</para><para>

The logical and an not operators do not unnecessarily evaluate the second
argument if the first argument can give the value of the operation
unambiguously.

</para><para>

Numbers are IEEE double precision floating point numbers, and integers are
special cases of numbers where the floating point part is zero. Divisions
are true floating point divisions, but @trunc, @floor, @ceil and @round
are supported for integer division. Addition, subtraction and multiplication
naturally work.

</para><para>
Example of where numbers are used:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $NUMFN()
  @locvar $num = (1*2-3)/4+5
  @locvar $num2 = @floor((1*2-3)/4)+5
  @locvar $math = @sqrt(@sin(@log(@exp(3))))
  @dump($num)
  @dump($num2)
  @dump($math)
  @if($num2 > 4)
    @dump("Not reached")
  @elseif($num > 4)
    @dump("Reached")
    @if($num2 == 4)
      @dump("Reached too")
    @endif
  @endif
@endfunction
@call $NUMFN()
</programlisting>

</para><para>

The @floor could be @trunc, @round or @ceil too for slightly different
semantics. Ceil gives value above the argument value, round implements standard
rounding, and @trunc is similar to @ceil and @floor but always goes toward
zero, so different for negative and positive. Absolute value can be obtained by
@abs, discarding a possible negative sign. The full @acos, @asin, @atan, @cos,
@sin, @tan trigonometry is supported but hyperbolic functions are not
supported. Exponentiation needs to be implemented with @exp and @log if using
some other base than e.

</para>
    </sect1>
    <sect1 xml:id="tree">
      <title>Tree</title>
      <!-- common operations -->
      <!-- fordict, fordictprev, dictprev, dictnext -->
    </sect1>
    <sect1 xml:id="functiondelayeval">
      <title>Functions and delayed evaluation</title>
    </sect1>
    <sect1 xml:id="functionglobalscope">
      <title>Functions, global variables and scoping</title>
      <!-- calling one function from another function -->
      <!-- difference between functions and built-ins -->
    </sect1>
  </chapter>
  <chapter xml:id="commands">
    <title>How Stirmake executes its commands</title>
    <!-- tab, at-tab, at-at-tab -->
    <!-- the dangers of shell expansion -->
    <!-- shell can still be manually invoked -->
    <!-- build command and file size database -->
    <!-- move madness -->
    <!-- ignore -->
    <!-- noecho -->
    <!-- ismake and automatic make detection -->
  </chapter>
  <chapter xml:id="cleaning">
    <title>Automated cleaning with stirmake</title>
    <!-- distrule and disttgt -->
  </chapter>
  <chapter xml:id="conditional">
    <title>Conditional compilation</title>
  </chapter>
  <chapter xml:id="exampleprojects">
    <title>Example projects</title>
    <sect1>
      <title>abce</title>
    </sect1>
    <sect1>
      <title>steamingatof</title>
    </sect1>
    <sect1>
      <title>prettyftoa</title>
    </sect1>
    <sect1>
      <title>rlctrans</title>
    </sect1>
    <sect1>
      <title>mploop</title>
    </sect1>
    <sect1>
      <title>quictest</title>
    </sect1>
    <sect1>
      <title>jmalloc</title>
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_stirmakelargescale">
  <title>Stirmake in large-scale systems</title>
  <chapter xml:id="multiproject">
    <title>Stirmake for entire project structures</title>
    <!-- including sub-projects -->
    <!-- invoking stirmake: smka, smkp, smkt -->
    <!-- controlling what to export with holey scopes -->
  </chapter>
  <chapter xml:id="oneprojectatatime">
    <title>Make revolution, one project at a time</title>
    <!-- Not everyone uses stirmake yet -->
    <!-- integration to jobserver and make autodetection -->
    <!-- backtick-equals, backtick-backtick-equals -->
    <!-- chomp -->
    <!-- getenv -->
    <!-- strwordlist -->
    <!-- recommendation for CC and CFLAGS support, both list of lists -->
    <!-- integration to subproject cleaning systems with clean hooks -->
    <!-- recdep and detouchrule/rectgtrule/mayberule -->
    <!-- make in same directory with mayberule -->
  </chapter>
  <chapter xml:id="scopingandsubdirectories">
    <title>Scoping and subdirectories</title>
    <!-- lexical vs dynamic: we support both -->
    <!-- holey scopes -->
    <!-- named scopes -->
    <sect1 xml:id="dirupdirdown">
      <title>Specifying library lists that work everywhere</title>
      <!-- introduce problem of specifying static dependencies -->
      <!-- @dirdown @dirup -->
    </sect1>
  </chapter>
  <chapter xml:id="examplelargeprojects">
    <title>Example large or complex projects</title>
    <sect1>
      <title>pptk</title>
    </sect1>
    <sect1>
      <title>nmsynproxy</title>
    </sect1>
    <sect1>
      <title>ldpairwall</title>
    </sect1>
    <sect1>
      <title>cghcpcli</title>
    </sect1>
    <sect1>
      <title>yale</title>
    </sect1>
    <sect1>
      <title>stirmake</title>
    </sect1>
    <sect1>
      <title>caj</title>
    </sect1>
    <sect1>
      <title>camftpd</title>
    </sect1>
    <sect1>
      <title>fastdiv</title>
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_advancedprogramming">
  <title>Advanced stirmake programming</title>
  <chapter xml:id="programmingwithamyplan">
    <title>Programming Stirmake with Amyplan</title>
    <!-- abce and amyplan -->
    <!-- installing amyplan in abce -->
    <!-- creating amyplan scripts -->
    <!-- lack of REPL due to being yacc-based -->
    <!-- constant strings and modifiable packet buffers, @str2pb, @pb2str -->
    <!-- pbnew -->
    <!-- packet buffer access with be8, le8, be16, be32, le16, le32 -->
    <!-- TODO: memcpy with packet buffers, needs abce support -->
    <!-- io streams and interacting with them -->
    <!-- math, fpclassify -->
    <!-- JSON -->
  </chapter>
  <chapter xml:id="advancedtricks">
    <title>Advanced tricks</title>
    <!-- pattern rules, TODO perhaps earlier? -->
    <!-- scopes stored in variables -->
    <!-- deponly for additional dependencies -->
    <!-- @order and @wait -->
    <!-- dynamically adding rules -->
    <!-- dynamically adding dependencies -->
    <!-- version conditionals and minimum version requirements, future b-ins -->
    <!-- finding gitmake version and version history -->
    <!-- hacking abce: need for all to be visible to abce at all times -->
  </chapter>
  </part>
</book>
