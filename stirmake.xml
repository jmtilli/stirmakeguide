<?xml version="1.0" encoding="UTF-8"?>
<!-- vim: set noai indentexpr&
-->

<!-- TODO somewhere: backslash at line end -->

<book xml:id="stirmake" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>Scalable true implementation of recursive make (stirmake)</title>
    <author>
      <personname>
        <firstname>Juha-Matti</firstname>
        <surname>Tilli</surname>
      </personname>
    </author>
    <copyright>
      <year>2023-2025</year>
      <holder>Juha-Matti Tilli</holder>
    </copyright>
  </info>
  <part xml:id="part_make">
  <title>Make, a historical tool</title>
  <chapter xml:id="make">
    <title>Make, the de facto build tool</title>

<sect1 xml:id="basics">
<title>Introduction to basics of make</title>

<para>

The first and most well-known build tool is make. Stuart Feldman authored make
in 1976 in Bell Labs. The idea of make is that while build can be done using a
shell script, a shell script executes all build commands uncondionally. In a
small project consisting of a single C language source file, this is not a
problem. However, larger projects can consist of multiple C source files, for
example Linux 6.17-rc7 contains 35778 source files, not counting header files.
If in a large project a small change is made, it should affect only on the code
that is dependent on it. For example, if a C source file is changed, only that
source file should be recompiled and any .a archive, shared library or
executable binary dependent on it should be re-linked.

</para><para>

A simple Makefile could be as follows:
<programlisting>
.PHONY: all
all: myprog
CC=cc
CFLAGS=-O1
myprog: myprog.c
	$(CC) $(CFLAGS) -o $@ $^
</programlisting>

</para><para>

Here $@ refers to the target name, wheras $^ contains all dependencies. Instead of $^, the first dependency can be referred to with $&lt;.

</para><para>

In this case, myprog is re-built only if nonexistent, or if its timestamp is
before the modification timestamp of myprog.c.

</para>

</sect1>
<sect1 xml:id="cleanandmakefiledep">
<title>Cleaning and dependency on Makefile</title>

<para>

A problem immediately appears. The file myprog does not depend on Makefile.
So if CFLAGS is modified, myprog won't be rebuilt. The answer to this generally
is two-fold.

</para><para>

Firstly, a target clean is added to clean everything:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
myprog: myprog.c
	$(CC) $(CFLAGS) -o $@ $^
</programlisting>

</para><para>

Then if CFLAGS is modified, the user can run "make clean" and then "make". This
demonstrates that the all-important "make clean" must be executed very often
with make-based build systems. This also demonstrates that it's all too easy to
forget something from "make clean". For example, in this simple Makefile, if a
new target secondprog is added, it needs to be added to its rule, but also to
"make clean" rule which is often forgotten.

</para><para>

Another possibility is adding dependency to Makefile, but this requires some
changes so that it's not given to CC as an argument:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
myprog: myprog.c Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.c,$^)
</programlisting>

</para><para>

Note that filter is a GNU make extension, and may not be available in other
implementations of make.

</para><para>

However, with both approaches, the "solution" is to clean or re-build
everything if the Makefile is changed. This is a problem in cases where the
Makefile is huge, but only one command to build one target is modified. Both
"solutions" in this case recompile everything, not just the target that had
a change in its command.

</para>

</sect1>
<sect1 xml:id="largerprojects">
<title>Somewhat larger single-directory projects</title>
<para>
In larger projects, it is generally preferred to not compile binary from C
sources directly, but instead create object files that are then linked:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
	rm -f myprog.o mylib.o
myprog: myprog.o mylib.o Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
myprog.o: myprog.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
mylib.o: mylib.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
</programlisting>

</para><para>

Now there are two unclean approaches in this Makefile. First is that the
information about what object files are there is repeated to three locations:
the rule of the object file, the linking rule, and the "make clean" phony rule.
The second is that if there are N object files, the command to build them is
repeated N times. These can be solved with some GNU make extensions:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
</programlisting>

</para><para>

Now the list of object files is specified only once, and the rule to build an
object from a source is common to all object files. Note that already at this
stage, the standard POSIX make is not enough, an GNU extensions have to be
used.

</para>

</sect1>
<sect1 xml:id="headerfile">
<title>Header file dependencies</title>

<para>

However, this more complex Makefile suffers from the fact that compiling
myprog.c into myprog.o most likely requires inclusion of a header file,
mylib.h. So myprog.o depends on mylib.h. This can be specified as an additional
dependency in the Makefile:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
myprog.o: mylib.h
</programlisting>

</para><para>

But however, this approach does not scale. Every time a C file is modified and
a new header file is added, it must be documented in the Makefile. Worse, a
header file can include other headers, and all of them should be documented
in the Makefile. Clearly, something better is needed.

</para><para>

Fortunately, most C compilers support outputting dependencies, which can be
imported:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS) $(DEPS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -o $@ $&lt;
-include $(DEPS)
</programlisting>

</para><para>

So the C compiler then creates the files myprog.d mylib.d that both myprog.o
and mylib.o depend on mylib.h. This is fully automatic. Before a build has been
made, the .d dependency files don't exist, but then everything must be
initially compiled anyway. In this case, -MM means omit system header files.
With -M only, system header file dependencies would be stored in the .d files.

</para><para>

Also notice that instead of include, you use -include. This is because the
dependency files don't exist the first time make is run.

</para><para>

Is the Makefile now good enough? No, because if mylib.h is renamed to
mylibpublic.h, then the .d files contain reference to the old mylib.h and make
notices it can't find that file. So an empty phony rule is needed to affect
make in such a manner that it doesn't exit when finding a reference to a
nonexistent header file. Fortunately, the -M option has -MP which adds the
phony rules and now "make clean" is not necessary if a header is renamed:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS) $(DEPS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -o $@ $&lt;
-include $(DEPS)
</programlisting>

</para><para>

However, this is not all that needs to be done. The .d files aren't updated
if a header file changes, only the .o files are updated. Fortunately, most
C compilers have an option to solve this: -MT:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS) $(DEPS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
-include $(DEPS)
</programlisting>

</para><para>

Now the .d files finally work just fine. However, there were a lot of
difficulties in the road to make the ultimate dependency file mechanism.

</para>
</sect1>

  </chapter>
  <chapter xml:id="makemultidirproject">
    <title>Where make fails, multi-directory projects</title>
    <sect1 xml:id="makedirsep">
      <title>Make with directory separators</title>

<para>

Let's consider you have a directory prog with file prog.c, and a directory lib
with files lib1.c and lib2.c, creating a static library file liblib.a. Then the
Makefile needs to create liblib.a and link it into prog. How to do this in
make?

</para><para>

Make does not have support for multiple nested directories, but make does
accept slash in file names. So let's create a top-level Makefile that compiles
stuff in directories prog and lib:
<programlisting>
.PHONY: all clean
all: prog/prog lib/liblib.a
CC=cc
CFLAGS=-O1
OBJLIB=lib/lib1.o lib/lib2.o
OBJPROG=prog/prog.o
OBJALL=$(OBJLIB) $(OBJPROG)
DEPALL=$(patsubst %.o,%.d,$(OBJALL))
clean:
	rm -f prog/prog lib/liblib.a
	rm -f $(OBJALL) $(DEPALL)
prog/prog: prog/prog.o lib/liblib.a Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^) $(filter %.a,$^)
lib/liblib.a: $(OBJLIB) Makefile
	rm -f $@
	ar rvs $@ $(filter %.o,$^)
$(OBJALL): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPALL): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
-include $(DEPALL)
</programlisting>

</para><para>

Note that in this program listing, the argument -o $@ to make is necessary.
Without it, the C compile is executed in the top-level directory, and the
output file would be stored into this top-level directory, not in the
subdirectory where the source file is.

</para><para>

This approach works but suffers from the drawback that in a project of 3000
subdirectories like in Linux kernel, the one and only top-level Makefile would
grow into a huge monster which makes its maintenance practically impossible.

</para>
    </sect1>
    <sect1 xml:id="makefileperdir">
      <title>Another approach: Makefile per directory</title>
<para>

Since clearly one top-level Makefile in a project does not offer enough
modularity, something better is needed. One possibility is that each
directory has a Makefile and the top-level Makefile calls make for each
subdirectory.

</para>
      <sect2 xml:id="recursivemaketest">
        <title>Let's try recursive make</title>
<para>

An environment for recursive make is presented here. It consists of top-level
directory and two subdirectories, lib and prog. The files in lib are:

</para><para>

hello.h:
<programlisting>
#ifndef _HELLO_H_
#define _HELLO_H_
void libhello(void);
#endif
</programlisting>

hello.c:
<programlisting>
#include &lt;stdio.h&gt;
#include "hello.h"
void libhello(void)
{
        printf("Hello, world!\n");
}
</programlisting>

Makefile:
<programlisting>
.PHONY: all clean
all: libhello.a
OBJ=hello.o
DEP=$(patsubst %.o,%.d,$(OBJ))
CC=cc
CFLAGS=-Wall
libhello.a: $(OBJ) Makefile
	rm -f $@
	ar rvs $@ $(filter %.o,$^)
$(OBJ): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEP): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
clean:
	rm -f libhello.a $(OBJ) $(DEP)
</programlisting>

</para><para>

The files in prog are:

</para><para>

prog.c:
<programlisting>
#include "hello.h"
int main(int argc, char **argv)
{
        libhello();
        return 0;
}
</programlisting>

Makefile:
<programlisting>
.PHONY: all clean
all: prog
OBJ=prog.o
DEP=$(patsubst %.o,%.d,$(OBJ))
CC=cc
CFLAGS=-Wall
CFLAGS+=-I../lib
prog: $(OBJ) Makefile ../lib/libhello.a
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^) $(filter %.a,$^)
$(OBJ): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEP): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
clean:
	rm -f prog $(OBJ) $(DEP)
</programlisting>

</para><para>

The top-level directory contains just this Makefile:

<programlisting>
CC=cc
CFLAGS=-Wall

.PHONY: all clean lib prog

all: lib prog

prog: lib

prog:
	$(MAKE) -C prog
lib:
	$(MAKE) -C lib

clean:
	$(MAKE) -C prog clean
	$(MAKE) -C lib clean
</programlisting>

</para><para>

Several problems are evident here. For example, the top-level Makefile needs to
have a rule that prog depends on lib. The reason being that prog contains one
program, prog.c, that needs to be linked to libhello.a which is a target in
lib. However, this linking needs to happen only for linking prog.o and
libhello.a into prog. So an optimization is possible: if we could build prog.o
and prog.d at the same time libhello.a is built, parallelism could be improved.
However, recursive make is incapable of implementing such an optimization, and
the need to know module-level dependencies in the top-level Makefile is clearly
not a scalable approach. If there are 3000 modules like in Linux kernel, having
full information about their dependencies in the top-level Makefile is not
scalable. Worse, the directory prog could contain subdirectories prog/prog1,
prog/prog2, prog/prog3 and the directory lib could contain sudirectories
lib/lib1, lib/lib2, lib/lib3. In this case, if the top-level Makefile invokes
Makefile in directory lib and in directory prog, it needs the prog: lib
dependency too, even though not all programs depend on all of the libraries.
These are drawbacks of artificially partitioning the build into disjoint
directed acyclic graphs as opposed to having a single directed acyclic graph
for the entire directory structure.

</para><para>

Another problem is evident by running "make clean" and then typing "cd prog;
make" which doesn't work since lib has not been built. So the system works well
only when "make" is invoked top-level, but it does not prevent running "make"
in a subdirectory. However, running "make" in a subdirectory can only work if
the dependencies have already been built.

</para><para>

Also, note how -Wall in CFLAGS needed to be modified in both prog and lib, even
though it is included in the top-level Makefile. The reason being is that not
only is the directed acyclic graph artificially divided into disjoint sets, but
also each of these disjoint sets corresponds to a different variable namespace.

</para><para>

Optimally, if the top-level Makefile specifies some variables, they would be
visible to all subdirectories, but if subdirectory lib defines something, it
would be visible only to subdirectories of lib, not to top-level subdirectory
prog. However, without some extra tricks, this is not possible in make.

</para>
      </sect2>
      <sect2 xml:id="nocommonnamespace">
        <title>Fixing no common namespace: include file</title>

<para>

One possibility of improving recursive make is by offering include files in
parent directories that the subdirectory Makefile can include. For example,
the top-level Makefile could be paired with top-level make.inc:

<programlisting>
CC=cc
CFLAGS=-Wall
</programlisting>

...and then each subdirectory would include this, for example prog/Makefile:

<programlisting>
include ../make.inc
.PHONY: all clean
all: prog
OBJ=prog.o
DEP=$(patsubst %.o,%.d,$(OBJ))
CFLAGS+=-I../lib
prog: $(OBJ) Makefile ../lib/libhello.a
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^) $(filter %.a,$^)
$(OBJ): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEP): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
clean:
	rm -f prog $(OBJ) $(DEP)
</programlisting>

Now CC does not need specifying and CFLAGS can be appended to, with the -Wall
already there. This usage of recursive make and include files that subdirectory
Makefiles can include provides a very convenient scoping for variables. Even
though the variables in top-level Makefile are not visible, at least the
variables in top-level make.inc are. And the child Makefiles can import
../make.inc and multiple nested subdirectories can be supported by having
make.inc in the subdirectories which includes ../make.inc always.

</para>

      </sect2>
      <sect2 xml:id="dangersofseparating">
        <title>Drawbacks and dangers of separating build to multiple DAGs</title>

<para>

However, the breakage of invoking make in a subdirectory of a cleaned project
structure is still there, and the top-level Makefile still needs to know the
module-level dependencies. Also some optimizations for parallel build cannot be
expressed with having module-level dependencies in the top-level Makefile. So
although now variable scoping is acceptable, the other problems of artificially
dividing the directed acyclic graph into disjoint sub-graphs is present.

</para><para>

These are the problems that Peter Miller identified in the famous paper <link
xlink:href="https://aegis.sourceforge.net/auug97.pdf">"Recursive Make
Considered Harmful"</link> already in 1997. Here it is recommended to read this
paper, as it make some convincing arguments about why it's harmful to not have
one single directed acyclic graph for the entire directory structure.  An
interesting obsevation is that Peter Miller's advice is not usually followed.
The reason probably is that recursive sub-make instances and top-level make.inc
include files offer very convenient isolation of variable scopes of those
sub-makes.

</para><para>

Also, parallel make becomes more difficult if there can be numerous sub-makes
running. GNU make has created a jobserver for such recursive invocations of
make, so that the top-level make creates a pair of pipe file descriptors. Then
the write end of the pipe is used to write several token characters. All
sub-makes can be executed if one token character per sub-make can be borrowed
from the pipe. Then each sub-make has one free job. If a sub-make can borrow
more tokens, it can start more jobs. All tokens are eventually returned to the
jobserver. This usage of recursive make and jobserver is so common that any
successor of Make can only succeed if it is compatible with this jobserver.

</para><para>

Because of these evident problems in recursive make, we should at least give
a try to Peter Miller's ideas about inclusive make. Peter Miller claims it is
not difficult to put into practice, but for complex projects, there are
difficulties which make it questionable whether make is a good tool for
creating complex build systems.

</para>

      </sect2>
    </sect1>
    <sect1 xml:id="inclusivemake">
      <title>Another approach: one Makefile, module.mk per directory</title>
<para>

When Peter Miller observed that make has often been misused recursively, he
advised that a better approach would be to have one top-level Makefile that
includes module.mk files in subdirectories. The theory is that this would
make large-scale build systems easy to create. However, due to lack of good
scoping, the build system creation and maintenance are both hard.

</para><para>

Firstly, if the module.mk based include file approach is chosen, the only
"make" instance is running for the top-level directory. All commands are
executed at this directory. So if there's a compiler that does not allow
manually setting the output file, the compiler may put the output file to
an incorrect directory, the top-level directory.

</para><para>

Another difficulty is that the variables the modules set are visible to
subsequent modules, but not modules that have been already imported. So if the
top-level Makefile sets CFLAGS, in practice no subdirectory can update the
CFLAGS, since the modification would leak to places it's not supposed to leak.
So subdirectories foo and bar should define CFLAGS_FOO and CFLAGS_BAR and leave
the CFLAGS unmodified.

</para><para>

The module.mk include file based approach is extremely difficult across project
boundaries. If your project has a git submodule, and you want to execute the
build system of the submodule, in practice it means recursive make, as
inclusion of files across project boundaries would be fragile, since there's no
way to enforce general policies like how variables are named to avoid variable
name clashes. So even die-hard inclusive make proponents switch to recursion in
across-project-boundaries use cases.

</para><para>

But, despite these drawbacks, it is definitely possible to create a simple
inclusive build system. One has to keep in mind that all command are executed
relative to the top-level directory, and that all variables need to have module
name in them to prevent variable name clashes.

</para><para>

The example build system has lib/hello.h:
<programlisting>
#ifndef _HELLO_H_
#define _HELLO_H_

void hello(void);

#endif
</programlisting>
...and lib/hello.c:
<programlisting>
#include "hello.h"
#include &lt;stdio.h&gt;
void hello(void)
{
  printf("Hello world\n");
}
</programlisting>
...and prog/prog.c:
<programlisting>
#include "hello.h"
int main(int argc, char **argv)
{
  hello();
}
</programlisting>

</para><para>

Now the build system for this structure consists of top-level Makefile:
<programlisting>
CC?="cc"
RM?="rm"
AR?="ar"
CFLAGS += -Wall -O3

.PHONY: all clean
all: lib/all prog/all

include lib/module.mk
include prog/module.mk

clean: lib/clean prog/clean
</programlisting>
...and lib/module.mk:
<programlisting>
DIR_LIB=lib
OBJS_LIB=$(DIR_LIB)/hello.o
DEPS_LIB=$(patsubst %.o,%.d,$(OBJS_LIB))

.PHONY: lib/all lib/clean

$(DIR_LIB)/all: $(DIR_LIB)/libhello.a

$(OBJS_LIB): %.o: %.c %.d
	$(CC) $(CFLAGS) $(CFLAGS_LIB) -c -o $@ $&lt;
$(DEPS_LIB): %.d: %.c
	$(CC) $(CFLAGS) $(CFLAGS_LIB) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;

$(DIR_LIB)/libhello.a: $(OBJS_LIB)
	$(RM) -f $@
	$(AR) rvs $@ $(filter %.o,$^)

$(DIR_LIB)/clean:
	rm -f $(DIR_LIB)/libhello.a $(OBJS_LIB) $(DEPS_LIB)

-include $(DIR_LIB)/*.d
</programlisting>
...and prog/module.mk:
<programlisting>
DIR_PROG=prog
OBJS_PROG=$(DIR_PROG)/prog.o
DEPS_PROG=$(patsubst %.o,%.d,$(OBJS_PROG))
CFLAGS_PROG=-Ilib

.PHONY: $(DIR_PROG)/all $(DIR_PROG)/clean

$(DIR_PROG)/all: $(DIR_PROG)/prog

$(OBJS_PROG): %.o: %.c %.d
	$(CC) $(CFLAGS) $(CFLAGS_PROG) -c -o $@ $&lt;
$(DEPS_PROG): %.d: %.c
	$(CC) $(CFLAGS) $(CFLAGS_PROG) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;

$(DIR_PROG)/prog: $(OBJS_PROG) lib/libhello.a
	$(CC) $(CFLAGS) $(CFLAGS_PROG) -o $@ $(filter %.o,$^) $(filter %.a,$^)

$(DIR_PROG)/clean:
	rm -f $(DIR_PROG)/prog $(OBJS_PROG) $(DEPS_PROG)

-include $(DIR_PROG)/*.d
</programlisting>

Note that if subdirectories need to have different CFLAGS, for example by
having custom -I include path arguments, the rules to compile .o and .d from .c
need to be specified separately in each subdirectory. There is no clean way to
specify them only once, since then subdirectories would use the same CFLAGS
everywhere.

</para>
      <!-- refer to makedirsep: commands are executed in subdirectory -->
      <!-- one common namespace -->
      <!-- dangers of one common namespace when including sub-projects: this is where even die-hard inclusive make proponents switch to recursion -->
    </sect1>
    <sect1 xml:id="parallelmake">
      <title>Parallel make, jobserver and lack of multiple targets</title>
<para>

Parallel make using the inclusive approach where one process sees the entire
directed acyclic graph, is simple. The make needs to be called with the -j4
option where 4 is the CPU core count.

</para><para>

One difficulty with parallel make is that GNU make is incapable of specifying
rules which create simultaneously more than one target. Code generation tools
like byacc, bison or flex often create a C source file and a header file at
the same time. If the command supports setting both output files, it is possible
to invoke it twice, once with C file as /dev/null, another time with header file
as /dev/null:
<programlisting>
test.lex.c: test.lex.l
	flex --outfile=$@ --header-file=/dev/null $&lt;
test.lex.h: test.lex.l
	flex --outfile=/dev/null --header-file=$@ $&lt;
text.lex.d: test.lex.h
text.lex.o: test.lex.h
</programlisting>
...but however, this way is not preferred since the command is executed twice
and consumes twice the CPU time an optimal implementation would consume.

</para><para>

Also, this approach to alternately set C file and header file as /dev/null
would not work for byacc. Byacc takes a prefix, given with the command-line
argument -b, and creates both .c and .h file for this prefix. Theoretically it
would be possible to execute byacc twice, once with prefix as "tmpc" and
another with prefix as "tmph", and then rename the files to their permanent
names, but unfortunately byacc embeds C preprocessor directives which tell the
line number of errors, and those embedded directive would have the "tmpc" or
"tmph".

</para><para>

Another possibility would be to just simply add the following:
<programlisting>
test.lex.c: test.lex.l
	flex --outfile=$@ --header-file=$(patsubst %.c,%.h,$@) $&lt;
text.lex.h: text.lex.c
</programlisting>
...but however, if text.lex.h is removed then with text.lex.c retained, make
would be incapable of creating it again.

</para><para>

Recursive uses of GNU make also need a certain trick, jobserver, to function
well. The problem with recursive make is that if it's invoked with -j4 for
example, each submake could create 4 jobs. If there are 4 submakes
simultaneously running, 16 jobs could be created at the worst simultaneously.
This is fixed by a jobserver, a pipe where characters for possible jobs are
added. Before sub-make is invoked, the caller must have a token for starting
the sub-make. Each sub-make has one "free" job thanks to the token needed to
start them, but running multiple simultaneous jobs would require obtaining more
tokens form the jobserver. The tokens are borrowed and eventually returned back
to the jobserver when all of the jobs have been executed.

</para><para>

In order to give jobserver details to sub-makes, it is important that sub-makes
are started with $(MAKE), not with "make". The $(MAKE) variable is what enables
the jobserver.

</para>
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_stirmakeintro">
  <title>Stirmake, a modern tool</title>
  <chapter xml:id="stirmakeintro">
    <title>Introducing stirmake</title>
    <sect1 xml:id="stirmakeinstall">
      <title>Compiling and installing stirmake</title>

<para>
Firstly, before stirmake can be used, flex, byacc and git need to be installed.
Flex is a very widely used tool, the most common implementation of lex today,
so its installation shouldn't be a problem, as most Unix-like operating systems
have an easy way to install it. Similarly, git is probably the most popular
version control system so installing it shouldn't be a problem. On the other
hand, byacc may cause problems in some environments. At least RedHat and
Debian-based systems such as Ubuntu contain byacc in their repositories. In
stirmake, bison was considered but rejected due to the GPL license, which byacc
does not suffer from. Fortunately, byacc should be easy to compile from sources
if the operating system does not have a ready-made package for it.

</para><para>

You also need GNU make to bootstrap stirmake, and the essential build tools
like C compiler and linker.

</para><para>

On RedHat, you would install the dependencies as follows:
<programlisting>
yum install flex byacc git
yum groupinstall 'Development Tools'
</programlisting>

</para><para>

On Debian and Ubuntu, it works as follows:
<programlisting>
apt install flex byacc git build-essential
</programlisting>

</para><para>

Now when dependencies have been installed, it's time to recursively clone and
install stirmake:
<programlisting>
git clone --recursive https://github.com/Aalto5G/stirmake
cd stirmake/stirc
make
./install.sh
</programlisting>

</para><para>

This installs stirmake to your ~/.local/bin that needs to be in the path. If
the directory did not exist, it probably isn't in the path and you may need to
re-log-in. Globally installing stirmake to /usr/local would happen as follows,
assuming it's already cloned:
<programlisting>
cd stirmake/stirc
make
sudo ./install.sh /usr/local
sudo mandb
</programlisting>

</para><para>

After it has been installed, try it:
<programlisting>
mkdir stirmaketry
cd stirmaketry
stirmake -a
smka
smkp
smkt
</programlisting>

</para><para>

All of the commands to invoke stirmake should print something like this:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/stirmaketry
stirmake: *** Stirfile not found. Exiting.
</programlisting>

</para><para>

They should also leave a .stir.db file containing just two lines out of which
the second is empty:
<programlisting>
@v2@

</programlisting>

</para><para>

Stirmake has been designed to work on POSIX systems but sometimes non-POSIX
functions are needed. For example, stirmake heavily benefits from availability
of madvise but does not require it. But what stirmake requires is the
possibility to map anonymous memory, whether it's MAP_ANON or MAP_ANONYMOUS
argument to mmap, or mmap from an open file /dev/zero. Also obsolete POSIX
setitimer is needed since the newer equivalents timer_settime etc. may not be
available on all systems like OpenBSD. The new POSIX utimensat heavily benefits
stirmake, but it can work with utimes if utimensat is not present. What is not
present in POSIX is getloadavg, but all the important operating systems like
BSDs, Linux, MacOS X and Solaris have it. Stirmake can work without it, but it
disables the functionality to reduce parallelism at times of increased load.
Also stirmake needs to know how many processors the machine has, which is a
non-POSIX call, and if the system does not support getting processor count,
then as default 1 is used. This only affects the -la and -ja options.

</para>

    </sect1>
    <sect1 xml:id="helloworld">
      <title>Compiling hello world</title>

<para>

Always "hello world" is the program that is written in any programming
language. Similarly, it must be easy to compile "hello world", a single source
file, in any build system.

</para><para>

First, let's create the .c source file hello.c:
<programlisting>
#include &lt;stdio.h&gt;
int main(int argc, char **argv)
{
  printf("Hello, world!\n");
  return 0;
}
</programlisting>

</para><para>

Then we can create the Stirfile to build it:
<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	["cc", "-o", $@, $&lt;]
</programlisting>

</para><para>

To actually build everything in this stirfile, type "smka".

</para><para>

Note the @-tabulator at the beginning of the command line. Similar to make,
tabulator must be present before the command. However, in this case, the @
specifier is used to bypass shell and use direct execution of the compiler.

</para><para>

If shell is needed, there are two options. First is to invoke sh with -c
argument:
<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	["sh", "-c", "cc -o " . $@ . " " . $&lt;]
</programlisting>

</para><para>

The second is to invoke it the same way as with make, omitting the @ character
before tabulator:
<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
	cc -o $@ $&lt;
</programlisting>

</para><para>

Both of these ways to invoke the shell are equal, as evidenced by the identical
output:
<programlisting>
stirmake: Using directory /home/juhis/smdb/shell
[., hello] sh -c cc -o hello hello.c
</programlisting>

</para><para>

Note that the rule 'all' is phony, but the rule 'hello' is not. A rule that
is not phony must create its target. If the target was not created, the rule
should probably be marked a @phonyrule. Standard GNU make does not warn if
a rule that is non-phony does not create its target. But stirmake does warn:
<programlisting>
@toplevel
@strict
'all': 'hello'
'hello': 'hello.c'
@	["cc", "-o", $@, $&lt;]
</programlisting>

</para><para>

This results in:
<programlisting>
stirmake: Using directory /home/juhis/smdb/shell
[., hello] cc -o hello hello.c
stirmake: *** Target all was not created by rule.
stirmake: *** Hint: use @phonyrule for phony rules.
stirmake: *** Hint: use @mayberule for rules that may or may not update target.
stirmake: *** Hint: use @rectgtrule for rules that have targets inside @recdep.
stirmake: *** Target all was not created by rule. Exiting.
</programlisting>

</para><para>

All of the rules here were marked @strict. @strict means that targets and
sources must be strings, using single or double quotes around them. If @strict
is not used, you may omit the quotes. However, this is not recommended, since
after @strict has been removed, the token 4/2 is not a mathematical expression
equal to 2, but it's a file 2 in directory 4. The reason here being that
maximum munch tokenization is used, and 4/2 is longer than 4, so the lexer goes
on to include more stuff for the token. In non-@strict mode, to calculate 4
divided by 2, you can add spaces or parentheses: 4 / 2 or (4)/(2).

</para><para>

Note that the @-tabulator syntax has a different way to specify variables than
the tabulator syntax. The @-tabulator syntax parses an arbitrary Amyplan
expression, which should create an array. This means for example variable
CC can be referred to by $CC. However, the tabulator-only syntax
requires $(CC). So you can have:
<programlisting>
@toplevel
@strict
$CC = "cc"
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	[$CC, "-o", $@, $&lt;]
</programlisting>

</para><para>

But with tabulator, this doesn't work:
<programlisting>
@toplevel
@strict
$CC = "cc"
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
	$CC -o $@ $&lt;
</programlisting>

</para><para>

But you must do this instead:
<programlisting>
@toplevel
@strict
$CC = "cc"
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
	$(CC) -o $@ $&lt;
</programlisting>

</para><para>

However, the $(CC) syntax works outside a tabulator line too:
<programlisting>
@toplevel
@strict
$(CC) = "cc"
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	[$(CC), "-o", $@, $&lt;]
</programlisting>

</para>

    </sect1>
    <sect1 xml:id="modularhellolib">
      <title>Modular hello from library</title>
<para>

The previous section demonstrated how to build a simple project with one
directory using stirmake. However, complex projects have numerous directories
and may have several binaries and several static libraries. We shall
emulate such a project by a modular "hello world" application where the
program invokes a function from a static library.

</para><para>

Let's create the top-level Stirfile first:
<programlisting>
@toplevel
@strict
$CC = "cc"
$RM = "rm"
$AR = "ar"
$CFLAGS = ["-Wall", "-O3"]
@phonyrule: 'all': 'lib/all' 'prog/all'
@dirinclude "lib"
@dirinclude "prog"
</programlisting>

Then let's create a directory lib with hello.c:
<programlisting>
#include "hello.h"
#include &lt;stdio.h&gt;
void hello(void)
{
  printf("Hello world\n");
}
</programlisting>
...and hello.h:
<programlisting>
#ifndef _HELLO_H_
#define _HELLO_H_

void hello(void);

#endif
</programlisting>
...and Stirfile:
<programlisting>
@subfile
@strict
$OBJS=["hello.o"]
$DEPS=@sufsuball($OBJS, ".o", ".d")

@phonyrule: 'all': 'libhello.a'

'libhello.a': $OBJS
@	[$RM, "-f", $@]
@	[$AR, "rvs", $@, @@suffilter($^, ".o")]

@patrule: $OBJS: '%.o': '%.c' '%.d'
@	[$CC, @$CFLAGS, "-c", "-o", $@, $&lt;]
@patrule: $DEPS: '%.d': '%.c'
@	[$CC, @$CFLAGS, "-MM", "-o", $@, $&lt;]

@cdepincludes @autophony @autotarget @ignore $DEPS
</programlisting>
...which contains the @-operator which is used to include a whole array into
another array. For example, [$CC, $CFLAGS] would not be an array of strings
since $CFLAGS is an array already. But [$CC, @$CFLAGS] is an array of strings
due to the @-operator. The same operator is used in [$AR, "rvs", $@,
@@suffilter($^, ".o")] where having only [$AR, "rvs", $@, @suffilter($^, ".o")]
would not be an array of strings. Also @cdepincludes @autophony @autotarget
@ignore was used to include C language header dependencies. Usually all of
@autophony (add phony rule for each header), @autotarget (add target file.d in
addition to file.o) and @ignore (don't stop if some dependency file doesn't
exist yet) are used together.

</para><para>

Note also the patrule. For example, the first patrule for $OBJS means that the
items in $OBJS must match pattern '%.o' where % is the wildcard. There has to
be exactly one wildcard in the target. The source files may have zero or one
wildcard(s) each, and the content from the target wildcard is used to fill the
possible '%' wildcard in the source files. It is important to note here that
these pattern rules are not similar to automatic rules in make. Every single
instantiation needs to occur in $OBJS. It is not possible to leave $OBJS away
and have stirmake deduce that pattern rule can be used for a target ending in
.o if there's a wildcard rule with target pattern '%.o'.

</para><para>
Then let's create a directory prog with prog.c:
<programlisting>
#include "hello.h"
int main(int argc, char **argv)
{
  hello();
}
</programlisting>
...and Stirfile:
<programlisting>
@subfile
@strict
$OBJS=["prog.o"]
$DEPS=@sufsuball($OBJS, ".o", ".d")
$CFLAGS += ["-I../lib"]

@phonyrule: 'all': 'prog'

@distrule: 'prog': $OBJS '../lib/libhello.a'
@	[$CC, @$CFLAGS, "-o", $@, @@suffilter($^, ".o"), \
	@@suffilter($+, ".a")]

@patrule: $OBJS: '%.o': '%.c' '%.d'
@	[$CC, @$CFLAGS, "-c", "-o", $@, $&lt;]
@patrule: $DEPS: '%.d': '%.c'
@	[$CC, @$CFLAGS, "-MM", "-o", $@, $&lt;]

@cdepincludes @autophony @autotarget @ignore $DEPS
</programlisting>
...which assigns to $CFLAGS in a manner that is visible only in this subdirectory. The other subdirectory "lib" does not have this modification to $CFLAGS. However, if the "prog" directory contained a subdirectory "prog/proghelpers", with its own Stirfile, then proghelpers would see this modification made to $CFLAGS in prog/Stirfile. This fully working nested recursive scoping is the main feature of Stirmake, making it better than GNU make.

</para><para>

Note the line continuation syntax where immediately before the newline the
backslash is placed, and the line continues on the following line. It
is important that the backslash is immediately before the newline and that
there are no spaces before it. Since stirmake uses newline for terminating
statements, like Python does, there has to be the line continuation syntax
for convenience. Implicit continuation with parentheses, square brackets or
curly braces is not supported.

</para><para>

Then several operations can be done. To fully clean the full directory
structure, use the command:
<programlisting>
smka -bc
</programlisting>
...which works in any directory, top-level directory or either of the two
subdirectories. Here "-b" means "clean distributable binaries" (marked with
@distrule) and "-c" means "clean everything else than distributable binaries".
If you want to clean only the subdirectory lib, use:
<programlisting>
cd lib
smkt -bc
</programlisting>

</para><para>

Another operation is building the structure. For example, the following command
works in any directory, top-level or subdirectory, as long as the directory
contains a Stirfile:
<programlisting>
smka
</programlisting>
...but another equivalent option would be:
<programlisting>
cd prog
smkt ../all
</programlisting>
...here "smka" means "stirmake all" and "smkt" means "stirmake this directory".
</para><para>

The power of stirmake is evident by running:
<programlisting>
smka -bc
cd prog
smkt
</programlisting>
...which builds all dependencies of the prog directory too, but nothing else
above the "prog" directory. With recursive make, this would not work:
<programlisting>
make clean
cd prog
make
</programlisting>
...since prog depends on lib, and the only way to build lib would be to invoke
"make" in the top-level directory.

</para>
    </sect1>
    <sect1 xml:id="environmentandconf">
      <title>Environment and configuration commands</title>

<para>

In standard make, if you do $(CC) $(CFLAGS), it uses both of these from
the environment, if the Makefile does not override them. This can cause
surprising bugs, where a Makefile works in one environment and not in another
environment. Stirmake is different, because in Stirmake if you want a
variable to be obtained from environment, you must obtain it manually. An
example:
<programlisting>
@toplevel
@strict
$CC=@strwordlist(@getenv("CC"), " ")
@if($CC[] == 0)
$CC=["cc"]
@endif
$CFLAGS=@strwordlist(@getenv("CFLAGS"), " ")
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	[@$CC, @$CFLAGS, "-o", $@, $&lt;]
</programlisting>

</para><para>

In this case, if the environment variable does not exist, @getenv returns @nil.
However, @strwordlist has a special feature which returns an empty array for
@nil argument. Here $CFLAGS is not mandatory so if it's [], nothing is done.
However, $CC must be defined, so the array is checked for emptiness and if
empty, the default value ["cc"] is used. Note how both $CC and $CFLAGS are
arrays. This is done because some environments may specify CC="cc -O3" for
example, although usually you would expect O3 to be in CFLAGS and not in CC.
However, because GNU make does not support true arrays, every variable is a
potential array with space as the separator.

</para><para>

The previous example showed how environment variables can be used. But in
some cases, you have to run a configuration command to get the arguments.
For example, when developing Python 3 applications, you would use the command
python3-config --includes. How to use it in Stirmake:
<programlisting>
@toplevel
@strict
$CC=["cc"]
$CFLAGS=["-Wall", "-O3"]
$PYCFLAGS``=["python3-config", "--includes"]
$CFLAGS += $PYCFLAGS
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	[@$CC, @$CFLAGS, "-o", $@, $&lt;]
</programlisting>
...so here the magic was the shell assignment operator ``. A similar operator
but with one backtick, `=, would give you the entire unprocessed output of
the command, with newline at end if the command printed a newline. This newline
may be removed with $VAR=@chomp($VAR). However, in this case you want an array
with space as the separator for compatibility with GNU make, so the assignment
operator needs to have two backticks, which interprets the output as an array
with space as the separator. Note that @strwordlist could be used here as
needed:
<programlisting>
@toplevel
@strict
$CC=["cc"]
$CFLAGS=["-Wall", "-O3"]
$PYCFLAGS`=["python3-config", "--includes"]
$PYCFLAGS=@strwordlist(@chomp($PYCFLAGS), " ")
$CFLAGS += $PYCFLAGS
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	[@$CC, @$CFLAGS, "-o", $@, $&lt;]
</programlisting>
..so the operator with two backticks is only a convenience operator for a
common case.
</para>
    </sect1>
    <sect1 xml:id="multiprocessing">
      <title>Multiprocessor machines</title>

<para>

Stirmake fully supports multiprocessor machines, but you need to invoke it
using the command-line option -j, which is true for make as well. However,
stirmake goes one step further with the -j option and supports CPU count
autodetection. So if you have an 8-core machine, you can run:
<programlisting>
smka -j4
</programlisting>
...to use 4 cores, or run:
<programlisting>
smka -j8
</programlisting>
...to use all 8 cores, which is synonymous for an 8-core machine with:
<programlisting>
smka -ja
</programlisting>

</para><para>

Stirmake makes it easy to implement parallel Stirfiles, and warns you about
situations that are arguably errors like a command not modifying its target,
but you need to remember that parallel Stirfiles need to contain all
dependencies and all targets. In contrast to standard make where a rule
cannot have more than one target, stirmake does not have such a restriction.
So, we can finally support flex in a way that works well for parallel stirmake:
<programlisting>
'test.lex.c' 'test.lex.h': 'test.lex.l'
@	["flex", "--outfile=".$@, "--header-file=".@sufsubone($@,".c",".h"), $&lt;]
@deponly: 'test.lex.d' 'test.lex.o': 'test.lex.h'
</programlisting>

</para><para>

For parallel GNU make, the best we can do (ugh!) is:
<programlisting>
test.lex.c: test.lex.l
	flex --outfile=$@ --header-file=/dev/null $&lt;
test.lex.h: test.lex.l
	flex --outfile=/dev/null --header-file=$@ $&lt;
text.lex.d: test.lex.h
text.lex.o: test.lex.h
</programlisting>
...which unnecessarily invokes flex twice.

</para><para>

Another useful feature available on any system that supports getting load
averages is a parallel stirmake that forks child processes only as long as load
averages are below a critical value. For example, on an 8-core machine, more
parallelism than 8 simultaneous processes probably doesn't help, and just in
case two different persons would on the same server invoke smka -j8, the
behavior of stirmake in such a situation is improved by smka -j8 -l8 which
forks new processes only as long as load average is below the threshold 8.
Naturally, -la is supported so maybe the ultimate parallel stirmake command
is:
<programlisting>
smka -ja -la
</programlisting>

</para><para>

One problem with parallel stirmake is that if two cc instances are running at
the same time, they are competing their access to the standard output and
standard error streams, so the error and warning messages from these two cc
instances can end up being mixed in the output. If you want to collect warning
messages together so that they can't end up being mixed, you can use the output
sync feature:
<programlisting>
smka -ja -la -Otarget
</programlisting>

This collects the output from each target together. Unfortunately, it may
disable the coloring of cc output, since cc no longer knows it's eventually
writing to a terminal (it first writes to a pipe, which is outputted by
stirmake to te terminal). The same non-coloring of output happens with GNU make
as well, so this problem is not unique to stirmake. However, with GNU make you
need the -j8 (or similar) option with -Otarget to end up having the coloring
problem, but with stirmake just -Otarget causes the coloring problem.

</para>

    </sect1>
    <sect1 xml:id="tracingdebugging">
      <title>Tracing and debugging</title>

<para>

Stirmake supports two ways of getting information. The lightweight way is
tracing, which prints information about why stirmake decided to execute
commands in a rule. This is a one-liner for every rule that's executed, and
contains the information why this rule was invoked. Example using the modular
hello world in <link linkend="modularhellolib">a preceding section</link>:

<programlisting>
smka -bc
smka -R
</programlisting>

...where the second command outputs:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/MODULARHELLO
update target 'lib/hello.d' due to: being nonexistent
update target 'prog/prog.d' due to: being nonexistent
[prog, prog/prog.d] cc -Wall -O3 -I../lib -MM -o prog.d prog.c
update target 'prog/prog.o' due to: being nonexistent
[prog, prog/prog.o] cc -Wall -O3 -I../lib -c -o prog.o prog.c
[lib, lib/hello.d] cc -Wall -O3 -MM -o hello.d hello.c
update target 'lib/hello.o' due to: being nonexistent
[lib, lib/hello.o] cc -Wall -O3 -c -o hello.o hello.c
update target 'lib/libhello.a' due to: being nonexistent
[lib, lib/libhello.a] rm -f libhello.a
[lib, lib/libhello.a] ar rvs libhello.a hello.o
ar: creating libhello.a
a - hello.o
update target 'prog/prog' due to: being nonexistent
[prog, prog/prog] cc -Wall -O3 -I../lib -o prog prog.o ../lib/libhello.a
</programlisting>

</para><para>

Note that the decision to build some target may not result in an immediate execution of the target, but it's queued and the queue is emptied later. So the
stirmake instance found that lib/hello.d needs to be built in first line of the
output, but built it much later, as the third comand to be executed.

</para><para>

Another way to obtain debugging information from stirmake, is the heavyweight
debug mode. It outputs a huge amount of debugging information:
<programlisting>
smka -bc
smka -d
</programlisting>
...where the second command outputs:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/MODULARHELLO
ADDING RULE
Rule all (.): add_rule
ADDING RULE
Rule lib/all (lib): add_rule
ADDING RULE
Rule lib/libhello.a (lib): add_rule
ADDING RULE
Rule lib/hello.o (lib): add_rule
ADDING RULE
Rule lib/hello.d (lib): add_rule
ADDING RULE
Rule prog/all (prog): add_rule
ADDING RULE
Rule prog/prog (prog): add_rule
ADDING RULE
Rule prog/prog.o (prog): add_rule
ADDING RULE
Rule prog/prog.d (prog): add_rule
reading cdepincludes from lib/hello.d
reading cdepincludes from prog/prog.d
considering all
 considering lib/all
  considering lib/libhello.a
   considering lib/hello.o
   ruleid by target lib/hello.c not found
    considering lib/hello.d
    ruleid by target lib/hello.c not found
     do_exec lib/hello.d
     ruleid for tgt lib/hello.c not found
     dep: 1759065139 86411140
     statting lib/hello.d
     immediate has_to_exec
     do_exec: has_to_exec 4
   rule 4 not executed, executing rule 3
  rule 3 not executed, executing rule 2
 rule 2 not executed, executing rule 1
rule 1 not executed, executing rule 0
 considering prog/all
  considering prog/prog
   considering prog/prog.o
   ruleid by target prog/prog.c not found
    considering prog/prog.d
    ruleid by target prog/prog.c not found
     do_exec prog/prog.d
     ruleid for tgt prog/prog.c not found
     dep: 1759065099 90314873
     statting prog/prog.d
     immediate has_to_exec
     do_exec: has_to_exec 8
   rule 8 not executed, executing rule 7
  rule 7 not executed, executing rule 6
   considering lib/libhello.a
   already execing lib/libhello.a
  rule 2 not executed, executing rule 6
 rule 6 not executed, executing rule 5
rule 5 not executed, executing rule 0
forking1 child
start args:
  NI E NM cc -Wall -O3 -I../lib -MM -o prog.d prog.c
end args
[prog, prog/prog.d] cc -Wall -O3 -I../lib -MM -o prog.d prog.c
select returned
 reconsidering prog/prog.o
  considering prog/prog.d
  already execed prog/prog.d
  do_exec prog/prog.o
  ruleid for tgt prog/prog.c not found
  dep: 1759065099 90314873
  ruleid 8/prog/prog.d not phony
  dep: 1759070742 375562092
  statting prog/prog.o
  immediate has_to_exec
  do_exec: has_to_exec 7
forking child
start args:
  NI E NM cc -Wall -O3 -I../lib -c -o prog.o prog.c
end args
[prog, prog/prog.o] cc -Wall -O3 -I../lib -c -o prog.o prog.c
select returned
 reconsidering prog/prog
 deps remain: 1
   dep_remain: 2 / lib/libhello.a
  considering lib/libhello.a
  already execing lib/libhello.a
 rule 2 not executed, executing rule 6
forking child
start args:
  NI E NM cc -Wall -O3 -MM -o hello.d hello.c
end args
[lib, lib/hello.d] cc -Wall -O3 -MM -o hello.d hello.c
select returned
 reconsidering lib/hello.o
  considering lib/hello.d
  already execed lib/hello.d
  do_exec lib/hello.o
  ruleid for tgt lib/hello.c not found
  dep: 1759065139 86411140
  ruleid 4/lib/hello.d not phony
  dep: 1759070742 399562149
  statting lib/hello.o
  immediate has_to_exec
  do_exec: has_to_exec 3
forking child
start args:
  NI E NM cc -Wall -O3 -c -o hello.o hello.c
end args
[lib, lib/hello.o] cc -Wall -O3 -c -o hello.o hello.c
select returned
 reconsidering lib/libhello.a
  considering lib/hello.o
  already execed lib/hello.o
  do_exec lib/libhello.a
  ruleid 3/lib/hello.o not phony
  dep: 1759070742 423562206
  statting lib/libhello.a
  immediate has_to_exec
  do_exec: has_to_exec 2
forking child
start args:
  NI E NM rm -f libhello.a
  NI E NM ar rvs libhello.a hello.o
end args
[lib, lib/libhello.a] rm -f libhello.a
[lib, lib/libhello.a] ar rvs libhello.a hello.o
ar: creating libhello.a
a - hello.o
select returned
 reconsidering lib/all
  considering lib/libhello.a
  already execed lib/libhello.a
  do_exec lib/all
  do_exec: mark_executed lib/all has_to_exec 1
    reconsidering all
    deps remain: 1
      dep_remain: 5 / prog/all
     considering prog/all
     already execing prog/all
    rule 5 not executed, executing rule 0
 reconsidering prog/prog
  considering lib/libhello.a
  already execed lib/libhello.a
  do_exec prog/prog
  ruleid 7/prog/prog.o not phony
  dep: 1759070742 395562139
  ruleid 2/lib/libhello.a not phony
  dep: 1759070742 423562206
  statting prog/prog
  immediate has_to_exec
  do_exec: has_to_exec 6
forking child
start args:
  NI E NM cc -Wall -O3 -I../lib -o prog prog.o ../lib/libhello.a
end args
[prog, prog/prog] cc -Wall -O3 -I../lib -o prog prog.o ../lib/libhello.a
select returned
 reconsidering prog/all
  considering prog/prog
  already execed prog/prog
  do_exec prog/all
  do_exec: mark_executed prog/all has_to_exec 1
    reconsidering all
     considering prog/all
     already execed prog/all
     do_exec all
     do_exec: mark_executed all has_to_exec 1

Memory use statistics:
  stringtab: 22
  ruleid_by_tgt_entry: 9
  tgt: 9
  stirdep: 13
  dep_remain: 9
  ruleid_by_dep_entry: 10
  one_ruleid_by_dep_entry: 13
  add_dep: 0
  add_deps: 0
  rule: 9
  ruleid_by_pid: 6
</programlisting>
...clearly, debug mode should be avoided unless the lighterweight trace mode
didn't reveal what happened and the heavyweight debug mode is needed then.

</para>

    </sect1>
  </chapter>
  <chapter xml:id="variabledatatypefunction">
    <title>Variables, data types and functions</title>
    <sect1 xml:id="dump">
      <title>Dump: hello from stirmake</title>

<para>

One of the most common tools you need all the time is @dump. It prints its argument in a format that works for all of the data types.

</para><para>

As an example, run this Stirfile:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@call @dump("Hello world")
@call @dump(123)
@call @dump(456.78)
@call @dump(@nil)
@call @dump(["foo", 5])
@call @dump({"bar": {"baz": [567, 89]}})
</programlisting>

</para><para>

It should print:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/SUBDIR
"Hello world"
123
456.77999999999997272
null
["foo", 5]
{"bar": {"baz": [567, 89]}}
stirmake: Nothing to be done.
</programlisting>

</para><para>

Note that dump is a debugging tool. If you want to print strings without the
quotation marks, you need some other tool. But a clear benefit of dump is that
it works for all data types.

</para><para>

Also note the @call specifiers before @dump. Every time an Amyplan statement
is run, without its output being saved to a variable, at top level (outside of
Amyplan functions), @call is needed. Amyplan has a distinction between
expressions and statements, and @dump is a statement. An alternative could be
calling @dump inside a function, in which case @call is not used:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $AMYPLANFUN()
  @dump("Hello world")
  @dump(123)
  @dump(456.78)
  @dump(@nil)
  @dump(["foo", 5])
  @dump({"bar": {"baz": [567, 89]}})
@endfunction
@call $AMYPLANFUN()
</programlisting>

</para><para>

Note that since @dump is a statement instead of an expression, this does not
work:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$DISCARD=@dump("Hello world")
$DISCARD=@dump(123)
$DISCARD=@dump(456.78)
$DISCARD=@dump(@nil)
$DISCARD=@dump(["foo", 5])
$DISCARD=@dump({"bar": {"baz": [567, 89]}})
@call @dump($DISCARD)
</programlisting>

</para>

    </sect1>
    <sect1 xml:id="variables">
      <title>Defining variables</title>

<para>

Variables can be defined outside of functions with the following syntax:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR ?= @nil
@call @dump($MYVAR)
$MYVAR = [2, "fof", {"bar": {"baz": [567, 89]}}]
$MYVAR += [12345, 54321]
$MYVAR ?= @nil
@call @dump($MYVAR)
</programlisting>

</para><para>

Note the several assignment operators here. ?= is conditional assigment,
assign only if the variable is nonexistent. = is the normal assigment
operator. For lists, += allows appending multiple elements to the list.

</para><para>

Generally, it is recommended that you define variables $CC and $CFLAGS if you
compile C code. Both of them ideally should be arrays, since some Makefiles in
fact assign some of the arguments to $CC into $CC and not into $CFLAGS. Also
defining variables for sources and targets as arrays is typical.

</para><para>

Inside functions, accessing and assigning into global variables requires
scope information, lexical or dynamic. An example of lexical scoping:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR ?= @nil
@function $MYFUN()
  @L$MYVAR = 5
@endfunction
@function $MYFUN2()
  @locvar $MYVAR=321
  @dump(@L$MYVAR)
  @dump($MYVAR)
@endfunction
@call $MYFUN()
@call $MYFUN2()
</programlisting>

</para><para>

Lexical scoping @L means that the function acceses the scope in which it was
defined. Dynamic scoping with @D would mean the function accesses the scope in
which it was called. Local variables are accessed without scope specifiers.  If
a variale access happens inside a function, it is a local variable as default.
Even function calls need scope specifiers:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR ?= @nil
@function $MYFUN()
  @L$MYVAR = 5
@endfunction
@function $MYFUN2()
  @locvar $MYVAR=321
  @L$MYFUN()
  @dump(@L$MYVAR)
  @dump($MYVAR)
@endfunction
@call $MYFUN2()
</programlisting>

</para><para>

Note that local variables need to be defined at the start of the function.
If you need a local variable set in the middle of the function, you need to
define it at the start, but you can assign @nil into it if you don't have
anything better to assign.

</para>
    </sect1>
    <sect1 xml:id="specvar">
      <title>Special variables</title>

<para>

There are five special variables: $@, $&lt;, $^, $+ and $|.

</para><para>

Out of these, $@, $lt; and $^ are the most often used. $@ is the name of the
first target. $&lt; is the name of the first source. $^ is the names of all
sources, with duplicates removed. $+ is the same as $^, but duplicate source
files are repeated in the exact same order, which may be useful sometimes for
linking static libraries that may have circular dependencies. $| is the names
of all order-only dependencies.

</para><para>

Out of these, $@ and$&lt; are strings and the others are arrays of strings.

</para>

    </sect1>
    <sect1 xml:id="datatypes">
      <title>Data types, finally we can have spaces in filenames!</title>

<para>

As mentioned already, stirmake supports strings and arrays. This is a
difference with make since make supports only strings, and arrays are emulated
by space-delimited strings, which means a filename cannot contain spaces.

</para><para>

Stirmake, via its programming language Amyplan and bytecode engine abce
supports the following data types:

<itemizedlist mark="bullet">
<listitem><para>@nil</para></listitem>
<listitem><para>Boolean: @false or @true</para></listitem>
<listitem><para>Number: IEEE double precision floating point, can contain both integers and floating-point numbers, all 32-bit integers can be exactly specified</para></listitem>
<listitem><para>String: an immutable sequence of 8-bit characters, with Unicode as UTF-8 if used</para></listitem>
<listitem><para>Packet buffer: a mutable sequence of bytes, can be converted from/to strings, contents can be modified, length can be modified</para></listitem>
<listitem><para>Array: a mutable sequence of any objects of any types</para></listitem>
<listitem><para>Tree: a mapping from immutable strings to any objects of any type. Note that numbers cannot be used as keys, but numbers can be converted to strings which can be used as keys.</para></listitem>
<listitem><para>I/O streams: a reference to a file which can be use to read and write data</para></listitem>
<listitem><para>Functions, which contain reference to the lexical scope, and which may be called with the correct number of arguments</para></listitem>
<listitem><para>Several internal data types not exposed to the programmer</para></listitem>
</itemizedlist>

</para><para>

The @type expression can be used to obtain the type of a variable, but as it is
a number that doesn't document itself, you should use @type of an example object
against which the type of the object is compared:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR = @nil
@call @dump(@type($MYVAR) == @type(@nil))
@call @dump(@type($MYVAR) == @type(@false))
$MYVAR = 543.21
@call @dump(@type($MYVAR) == @type(123))
@call @dump(@type($MYVAR) == @type("foo"))
$MYVAR = @tostring($MYVAR)
@call @dump(@type($MYVAR) == @type("foo"))
$MYVAR = @tonumber($MYVAR)
@call @dump(@type($MYVAR) == @type(123))
$MYVAR = @tostring($MYVAR)
@call @dump(@type($MYVAR) == @type("foo"))
@call @dump(@type($MYVAR) == @type(@pbnew()))
$MYVAR = @str2pb($MYVAR)
@call @dump(@type($MYVAR) == @type("foo"))
@call @dump(@type($MYVAR) == @type(@pbnew()))
$MYVAR = @pb2str($MYVAR,0,$MYVAR{@})
@call @dump(@type($MYVAR) == @type("foo"))
@call @dump(@type($MYVAR) == @type(@pbnew()))
$MYVAR = [1,2,3]
@call @dump(@type($MYVAR) == @type([]))
@call @dump(@type($MYVAR) == @type({}))
</programlisting>

</para><para>

Note the @tostring and @tonumber operations which can be used to convert
between strings and numbers, and the @str2pb and @pb2str operations which can
be used to convert between strings and packet buffers. The @pb2str operation
requires starting index (0-based starts from 0) and length of slice to take
from the packet buffer. The @str2pb always takes the entire string, but <link
linkend="string">strings can be sliced with @strsub</link> if needed, and then
converted to a packet buffer with @str2pb of the sliced string.

</para>

    </sect1>
    <sect1 xml:id="conditionals">
      <title>Conditionals</title>

<para>
Stirmake supports conditionals both at top level and inside functions. Example:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':

$A=@true
$B=@false

@if($A)
  @call @dump("A is true")
@else
  @call @dump("A is false")
@endif

@if($A)
@deponly: 'all': 'specialrule'
@phonyrule: 'specialrule':
@	["echo", "A is true"]
@endif

@function $CHECKB($b)
  @if($b)
    @dump("B is true")
  @elseif(!$b)
    @dump("B is false")
  @endif
@endfunction

@call $CHECKB($B)
</programlisting>

</para><para>

Top-level conditionals can be used to affect which rules and dependencies are
existing in the data structures of stirmake. So, in the previous example, if
you modify $A to be false, the phony specialrule is not executed.

</para><para>

A particularly useful conditional is top-level version conditional. If you have
stirmake version 7e548edc5aa47312a1c517503947aa02e5e20329 (can be checked with
stirmake -v, the whole version history can be checked with stirmake -G), then
you can define:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':

@if(@version("7e548edc5aa47312a1c517503947aa02e5e20329"))
@deponly: 'all': 'specialrule'
@phonyrule: 'specialrule':
@	["echo", "stirmake version is recent"]
@endif

</programlisting>
...which invokes the specialrule only if stirmake version is at least
7e548edc5aa47312a1c517503947aa02e5e20329. Note that git version numbering is
used here, so the version number is a SHA-1 hash.

</para>

    </sect1>
    <sect1 xml:id="loops">
      <title>Loops</title>

<para>

Stirmake supports two kinds of loops: standard loops and tree loops. We begin
by explaining standard loops. Tree loops will be explained when
<link linkend="tree">trees are introduced</link>.

</para><para>

The basic loop is @while. It executes its body as long as the condition
is true. An example:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $ANGLE($angle)
  @while($angle&lt;0)
    $angle = $angle + 360
  @endwhile
  @return $angle
@endfunction
@call @dump($ANGLE(-405))
</programlisting>
...this function returns 315 for the argument -405.

</para><para>

Another loop, @once, for error handling may be useful:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $ERRSTATUS1()
  @dump("ERRSTATUS1 called")
  @return @true
@endfunction
@function $ERRSTATUS2()
  @dump("ERRSTATUS2 called")
  @return @false
@endfunction
@function $ERRSTATUS3()
  @dump("ERRSTATUS3 called")
  @return @true
@endfunction
@function $COMBINED()
  @locvar $ok = @true
  @once
    $ok = @L$ERRSTATUS1()
    @if(!$ok)
      @break
    @endif
    $ok = @L$ERRSTATUS2()
    @if(!$ok)
      @break
    @endif
    $ok = @L$ERRSTATUS3()
    @if(!$ok)
      @break
    @endif
  @endonce
  @return $ok
@endfunction
@call @dump($COMBINED())
</programlisting>
...note how here the elegant @break inside @once allows emulating goto used in
C language for error handling, without the ugliness of an arbitrary goto. If
only @break is used, @once is not a loop. However, it is possible to modify it
to be an actual infinite loop with @continue:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $ERRSTATUS1()
  @dump("ERRSTATUS1 called")
  @return @true
@endfunction
@function $ERRSTATUS2()
  @dump("ERRSTATUS2 called")
  @return @false
@endfunction
@function $ERRSTATUS3()
  @dump("ERRSTATUS3 called")
  @return @true
@endfunction
@function $COMBINED()
  @locvar $ok = @true
  @once
    $ok = @L$ERRSTATUS1()
    @if(!$ok)
      @break
    @endif
    $ok = @L$ERRSTATUS2()
    @if(!$ok)
      @continue
    @endif
    $ok = @L$ERRSTATUS3()
    @if(!$ok)
      @break
    @endif
  @endonce
  @return $ok
@endfunction
@call @dump($COMBINED())
</programlisting>
...now the program alternately prints:
<programlisting>
"ERRSTATUS1 called"
"ERRSTATUS2 called"
"ERRSTATUS1 called"
"ERRSTATUS2 called"
...
</programlisting>

</para><para>

Where @continue inside @once is useful, is operations that need retrying. For
example, if a system can encounter deadlocks, the proper way to handle them is
random exponential back-off, and @once with @continue is the natural construct
to implement the random exponential back-off.

</para><para>

Of course, the standard @for is supported as well:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $DUMPALL($array)
  @locvar $i = @nil
  @for($i = 0, $i &lt; $array[], $i=$i+1)
    @dump($array[$i])
  @endfor
@endfunction
@call $DUMPALL([1, "2", 3.5, @false, @nil])
</programlisting>

</para><para>

And if you want to break outside of a loop not the innermost, @break (and
@continue) take an integer argument:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $DUMPALL($array)
  @locvar $i = @nil
  @locvar $j = @nil
  @for($i = 0, $i &lt; $array[], $i=$i+1)
    @for($j = 0, $j &lt; 10, $j=$j+1)
      @dump($j)
      @dump($array[$i])
      @if($i == 2 &amp;&amp; $j == 2)
        @break 2
      @endif
    @endfor
  @endfor
@endfunction
@call $DUMPALL([1, "2", 3.5, @false, @nil])
</programlisting>
...here the argument 2 means "break out of 2 loops".

</para>
    </sect1>
    <sect1 xml:id="string">
      <title>String</title>

<para>

Stirmake uses the immutable string data type to represent character strings.
There is no character data type, so if a data type is needed for character,
a 1-character long string can be used, or an integer can be used to represent
character index.

</para><para>

The most common operation with strings is appending:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MID = 'ab'
$JOINT = '0123456789' . $MID . 'cdef'
@call @dump($JOINT)
</programlisting>
...which prints 0123456789abcdef

</para><para>

String characters can be accessed (but not modified as strings are immutable)
by specifying the @ operator and index inside square brackets. Note the
@ operator is present to specify it's string indexing; without it, the indexing
would be array indexing. It works as follows:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$STR = '123456789'
@call @dump($STR[@3])
</programlisting>
...which prints 52, which is the character index of '4'. To convert it into
'4':
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$STR = '123456789'
@call @dump(@strfromchr($STR[@3]))
</programlisting>

</para><para>

If a string may or may not have newline at its end, it can be removed with
@chomp:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$YESNL = "foo\n"
$NONL = "bar"
@call @dump(@chomp($YESNL))
@call @dump(@chomp($NONL))
</programlisting>

...which prints foo and bar, without the newline in foo.

</para><para>

String length can be queried:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$STR = '123456789'
@call @dump($STR[@])
</programlisting>

...which prints 9.

</para><para>

Strings cannot be compared by operators &lt;, &lt;=, &gt;, &gt;=; ==, != since
those are reserved for mathematical expressions. String comparison is made
by using @strcmp which returns negative, 0 or positive:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$STR1 = "a"
$STR2 = "z"
@call @dump(@strcmp($STR1, $STR2))
@call @dump(@strcmp($STR2, $STR1))
</programlisting>
...in this case, the first @strcmp returns -25 since "a" is smaller than "z".
The second returns 25.

</para><para>

Strings can be converted to lowercase, uppercase and reversed:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MIXEDCASE = "ABCdef"
@call @dump(@strupper($MIXEDCASE))
@call @dump(@strlower($MIXEDCASE))
@call @dump(@strreverse($MIXEDCASE))
</programlisting>

</para><para>

Strings can be converted to numbers and back to strings:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$NUMSTR = "123.5"
@call @dump($NUMSTR)
@call @dump(@tonumber($NUMSTR))
@call @dump(@tostring(@tonumber($NUMSTR)+100))
</programlisting>

</para><para>

Finding index of a substring inside a string is supported:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$WHOLE="abc123ABC"
@call @dump(@strstr($WHOLE, "123"))
@call @dump(@strstr($WHOLE, "456"))
</programlisting>
...which prints 3 and null.

</para><para>

String repetition in supported:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$SHORT="012"
@call @dump(@strrep($SHORT, 3))
</programlisting>
...which prints 012012012

</para><para>

Whitespace at start and end can be stripped:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$WS="\t   012 "
@call @dump(@strstrip($WS, " \t"))
</programlisting>

</para><para>

Substrings can be obtained:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$NUMS="0123456789"
@call @dump(@strsub($NUMS, 3, 5))
</programlisting>
...where start index 3 is included but end index 5 is not.

</para><para>

Global search&amp;replace (substitution) is supported:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$STR="Testing string substitution with this string"
@call @dump(@strgsub($STR, "string", "String"))
</programlisting>

</para><para>

String words can be counted:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$STR="Testing string word count with this string"
@call @dump(@strwordcnt($STR, " "))
</programlisting>

</para><para>

Individual words can be selected:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$STR="Testing string word count with this string"
@call @dump(@strword($STR, " ", 2))
</programlisting>

</para><para>

Individual characters can be replaced with their numerical values, creating
a new string as strings are immutable:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$STR="abc012"
@call @dump(@strset($STR, 2, ("C")[@0]))
</programlisting>

</para><para>

The two remaining standard string operations are conversions between
strings and arrays. For example, strings can be split into word lists, with
custom separator:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$STR="Testing string word list."
@call @dump(@strwordlist($STR, " "))
</programlisting>

and lists of strings can be joined with custom separator:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$AR=["Testing", "string", "word", "list."]
@call @dump(@strlistjoin(" ", $AR))
</programlisting>

</para>

    </sect1>
    <sect1 xml:id="array">
      <title>Array</title>
<para>

Arguably the most important data type in Stirmake is array. It allows doing
something Make cannot do, to have list of file names that may or may not
include spaces in them. Arrays are defined by square brackets and accessed
by square brackets too:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$ARRAY=[1,2,3,4,5]
@call @dump($ARRAY[2])
</programlisting>

Indexing is zero-based so the previous listing prints 3. Array length can
be queried by leaving the index between square brackets away:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$ARRAY=[5,4,3,2,1]
@call @dump($ARRAY[])
</programlisting>
...which prints 5, the length of the array.

</para><para>

Arrays can be appended to:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $APPEND()
  @locvar $ARRAY=[5,4,3,2,1]
  @append($ARRAY, 2)
  @appendlist($ARRAY, [3,4,5])
  @dump($ARRAY)
@endfunction
@call $APPEND()
</programlisting>
...which prints [5,4,3,2,1,2,3,4,5].

</para><para>

Array slicing is supported too:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $SPLICE()
  @locvar $ARRAY=[0,1,2,3,4,5,6,7]
  @dump(@splice($ARRAY, 2, 5))
@endfunction
@call $SPLICE()
</programlisting>
...which prints [2, 3, 4] so it includes the start index (2) but not the end
index (5).

</para><para>

Removing the last element of an array is supported:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $POP()
  @locvar $ARRAY=[5,4,3,2,1]
  @locvar $LAST=$ARRAY[-]
  @dump($LAST)
  @dump($ARRAY)
@endfunction
@call $POP()
</programlisting>
...which prints 1 and then [5,4,3,2].

</para><para>

Array items can be assigned to:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $ASSIGN()
  @locvar $ARRAY=[5,4,3,2,1]
  $ARRAY[2] = 50
  @dump($ARRAY)
@endfunction
@call $ASSIGN()
</programlisting>
...which prints [5, 4, 50, 2, 1].

</para><para>

Embedding an existing array into a new array is possible with the @-operator:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $EMBED()
  @locvar $SHORT=[1,2,3]
  @locvar $LONG=[9,8,7,@$SHORT,7,8,9]
  @dump($LONG)
@endfunction
@call $EMBED()
</programlisting>
...which prints [9,8,7,1,2,3,7,8,9].

</para><para>

There is also support outside of functions to append-assign into an array:
<programlisting>
@toplevel
@strict
$ARRAY=[1,2,3]
$ARRAY += [4,5,6]
@phonyrule: 'all':
@call @dump($ARRAY)
</programlisting>
...which prints [1,2,3,4,5,6] and which has an equivalent that works inside
functions too:
<programlisting>
@toplevel
@strict
$ARRAY=[1,2,3]
$ARRAY=[@$ARRAY,4,5,6]
@phonyrule: 'all':
@call @dump($ARRAY)
</programlisting>

</para>
    </sect1>
    <sect1 xml:id="simpletypes">
      <title>Simple data types: number, boolean, nil</title>
<para>

The simplest data type that Stirmake supports is nil, which can contain just
one variable: @nil. To compare if something is @nil, you need to get the @type
of the object, since two equal signs are meant for numeric comparison and @nil
is not a number. However, its type is a number. Checking for @nil-ness is as
follows:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $CHECKNIL()
  @locvar $isnil = @nil
  @locvar $notnil = "nil"
  @if(@type($isnil) == @type(@nil))
  @dump("Is nil 1")
  @endif
  @if(@type($notnil) == @type(@nil))
  @dump("Is nil 2")
  @endif
@endfunction
@call $CHECKNIL()
</programlisting>

</para><para>

Booleans can have two values: @false and @true. Every comparison operator
returns a boolean. Booleans are used in @if statements as follows:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $BOOLFN()
  @locvar $isnil = @nil
  @locvar $bool = (@type($isnil) == @type(@nil))
  @if($bool)
  @dump("Boolean is true")
  @endif
@endfunction
@call $BOOLFN()
</programlisting>

</para><para>

Also, the loops @while and @for use booleans to decide whether to continue.
With booleans, you can use the &amp;&amp;, || and ! operators for logical and,
logical or and not, respectively:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $BOOLOP()
  @locvar $isnil = @nil
  @locvar $bool = !(@true &amp;&amp; (@false || @true))
  @if($bool)
  @dump("Boolean is true")
  @else
  @dump("Boolean is false")
  @endif
@endfunction
@call $BOOLOP()
</programlisting>

</para><para>

The logical and an not operators do not unnecessarily evaluate the second
argument if the first argument can give the value of the operation
unambiguously.

</para><para>

Numbers are IEEE double precision floating point numbers, and integers are
special cases of numbers where the floating point part is zero. Divisions
are true floating point divisions, but @trunc, @floor, @ceil and @round
are supported for integer division. Addition, subtraction and multiplication
naturally work.

</para><para>
Example of where numbers are used:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $NUMFN()
  @locvar $num = (1*2-3)/4+5
  @locvar $num2 = @floor((1*2-3)/4)+5
  @locvar $math = @sqrt(@sin(@log(@exp(3))))
  @dump($num)
  @dump($num2)
  @dump($math)
  @if($num2 > 4)
    @dump("Not reached")
  @elseif($num > 4)
    @dump("Reached")
    @if($num2 == 4)
      @dump("Reached too")
    @endif
  @endif
@endfunction
@call $NUMFN()
</programlisting>

</para><para>

The @floor could be @trunc, @round or @ceil too for slightly different
semantics. Ceil gives value above the argument value, round implements standard
rounding, and @trunc is similar to @ceil and @floor but always goes toward
zero, so different for negative and positive. Absolute value can be obtained by
@abs, discarding a possible negative sign. The full @acos, @asin, @atan, @cos,
@sin, @tan trigonometry is supported but hyperbolic functions are not
supported. Exponentiation needs to be implemented with @exp and @log if using
some other base than e.

</para>
    </sect1>
    <sect1 xml:id="tree">
      <title>Tree</title>

<para>

Stirmake supports an associative array, which is sometimes varyingly called
"tree" or "dictionary". It is a red-black tree. The keys used in this red-black
tree are immutable strings. Nothing else, like numbers, are supported as keys,
but obviously any number can be converted to its textual representation with
ease.

</para><para>

Here is an example of defining a tree:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $TREE()
  @locvar $tree = { \
    "ab": 123, \
    "cd": [4,5,6], \
    "ef": @true, \
    "gh": @nil, \
    "ij": "str" \
  }
  @dump($tree)
@endfunction
@call $TREE()
</programlisting>

</para><para>

Once you have defined a tree, you can get from it, add to it and delete from it:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $TREEMOD()
  @locvar $tree = { \
    "ab": 123, \
    "cd": [4,5,6], \
    "ef": @true, \
    "gh": @nil, \
    "ij": "str" \
  }
  @dump($tree{"ab"}) # Get existing value
  $tree{"ab"} = 321 # Modify existing value
  $tree{"a"} = 432 # Add new value
  $tree{"ij"} = - # Remove value
  @dump($tree)
@endfunction
@call $TREEMOD()
</programlisting>

</para><para>

It is also possible to query membership and get length:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $TREEQUERIES()
  @locvar $tree = { \
    "ab": 123, \
    "cd": [4,5,6], \
    "ef": @true, \
    "gh": @nil, \
    "ij": "str" \
  }
  @dump($tree{@?"a"}) # Check existence, false
  @dump($tree{@?"ab"}) # Check existence, true
  @dump($tree{}) # Get length, 5
@endfunction
@call $TREEQUERIES()
</programlisting>

</para><para>

There are fordict and fordictprev loops to iterate through a tree:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $TREELOOPS()
  @locvar $key = @nil
  @locvar $val = @nil
  @locvar $tree = { \
    "ab": 123, \
    "cd": [4,5,6], \
    "ef": @true, \
    "gh": @nil, \
    "ij": "str" \
  }
  @fordict $key, $val ($tree)
    @dump($key . " = " . @jsonenc($val))
  @endfor
  @dump("-----")
  @fordictprev $key, $val ($tree)
    @dump($key . " = " . @jsonenc($val))
  @endfor
@endfunction
@call $TREELOOPS()
</programlisting>

</para><para>

It is possible to get previous and next key from trees, and @nil as argument
means get first or last key.

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $TREEPREVNEXT()
  @locvar $tree = { \
    "ab": 123, \
    "cd": [4,5,6], \
    "ef": @true, \
    "gh": @nil, \
    "ij": "str" \
  }
  @dump(@dictnext($tree, "ef"))
  @dump(@dictprev($tree, "ef"))
  @dump(@dictnext($tree, "eg"))
  @dump(@dictprev($tree, "eg"))
  @dump(@dictnext($tree, "e"))
  @dump(@dictprev($tree, "e"))
  @dump(@dictnext($tree, @nil))
  @dump(@dictprev($tree, @nil))
@endfunction
@call $TREEPREVNEXT()
</programlisting>

</para>
    </sect1>
    <sect1 xml:id="functiondelayeval">
      <title>Functions and delayed evaluation</title>
<para>

Consider the following Stirfile:

<programlisting>
@toplevel
@strict
'hello.o': 'hello.c'
@	["cc", "-Wall", "-O3", "-c", "-o", $@, $&lt;]
</programlisting>

...which arguably is not very clean since if new source files are added,
every file needs to repeat the command used to build it. It is possible
to slightly eliminate some boilerplate arguments by defining $CC and $CFLAGS:

<programlisting>
@toplevel
@strict
$CC="cc"
$CFLAGS=["-Wall", "-O3"]
'hello.o': 'hello.c'
@	[$(CC), @$(CFLAGS), "-c", "-o", $@, $&lt;]
</programlisting>

...but there is the problem that $@ and $&lt; need to be repeated every time.
They cannot be evaluated during the top-level $CFLAGS assignment since at the
time the $CFLAGS assignment is evaluated, $@ and $&lt; are not yet known. So
delayed evaluation is what's missing, and the simple assignment syntax of
Stirmake does not offer that.

</para><para>

Of course, since make supports delayed evaluation, stirmake has to have
something similar with a very handy syntax, or else stirmake cannot be
considered the ultimate successor to make. In stirmake, delayed evaluation
is done by using single-line functions and calling them. How to have
delayed evaluation is best explained by an example:

<programlisting>
@toplevel
@strict
$CC="cc"
$CFLAGS=["-Wall", "-O3"]
$CCCMD&lt;&gt;=[$(CC), @$(CFLAGS), "-c", "-o", $@, $&lt;]
'hello.o': 'hello.c'
@	$CCCMD&lt;&gt;
</programlisting>

Note the &lt;&gt; operator which has dual purpose. In top-level assignments, it
means "create a function out of this expression which takes no arguments". When
used in shell commands or any other similar location, &lt;&gt; means "if the
preceding value is a function, call it with no arguments, otherwise use the
value as-is".

</para><para>

This way, a lot of boilerplate commands can be avoided. However, there is still
another problem. If a static library is created out of this hello.o that was
just compiled, the static library creation requires not one but two commands.
The first is "rm -f libstatic.a" and the second is "ar rvs libstatic.a
hello.o". If the first command is omitted, after several repeated runs,
libstatic.a may end up having some old deleted object files that are no longer
used. So there is a need for syntax that has several commands in a single
function. That is supported by modifying the @-tab at the beginning of the
command line into @@-tab, and defining $ARCMDS accordingly:

<programlisting>
@toplevel
@strict
$CC="cc"
$CFLAGS=["-Wall", "-O3"]
$CCCMD&lt;&gt;=[$(CC), @$(CFLAGS), "-c", "-o", $@, $&lt;]
$ARCMDS&lt;&gt;=[["rm", "-f", $@], ["ar", "rvs", $@, @@suffilter($^, ".o")]]
'libstatic.a': 'hello.o'
@@	$ARCMDS&lt;&gt;
'hello.o': 'hello.c'
@	$CCCMD&lt;&gt;
</programlisting>

The @@-tab means that the expression creates not a single command (array of
strings) but a list of commands (array of arrays of strings).

</para>
    </sect1>
    <sect1 xml:id="functionglobalscope">
      <title>Functions, global variables and scoping</title>
<para>

The previous single-line function definitions with &lt;&gt; operator did not
need to specify the type of scoping used, lexical or dynamic. The single-line
functions defined with &lt;&gt; use dynamic scoping as default and may not
have local variables.

</para><para>

However, there are longer multi-line functions supported by Stirmake that have
been demonstrated several times already. They use @L before variable name
if lexical scoping is needed or @D before variable name if dynamic scoping
is needed. An example:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$VAR = 1
$ARG = 2
@function $FUN1($ARG)
  @locvar $VAR = 5
  @dump($ARG)
  @dump(@L$ARG)
  @dump(@D$ARG)
  @dump($VAR)
  @dump(@L$VAR)
  @dump(@D$VAR)
@endfunction
@beginscope
  $VAR = 3
  $ARG = 4
  @call $FUN1(6)
@endscope
</programlisting>

It is recommended for the reader to guess what the function prints before
running it.

</para><para>

Note that calling functions is similar to accessing a variable. The scoping
must be specified, or else $FUN1(6) would refer to calling a local variable
$FUN1 having a function with argument 6. Since functions cannot be defined as
local variables, this is guaranteed to fail (unless a local variable function
pointer is created). Note that code outside functions (like the @call $FUN1(6))
and code in single-line &lt;&gt; delayed evaluation functions uses dynamic
scoping by default and then the concept of local variables is meaningless. An
example of calling a function using dynamic and lexical scoping:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $FUN1($ARG)
  @dump(@L$FUN2($ARG))
  @dump(@D$FUN2($ARG))
@endfunction
@function $FUN2($ARG)
  @return 1+$ARG
@endfunction
@beginscope
  @function $FUN2($ARG)
    @return 2+$ARG
  @endfunction
  @call $FUN1(6)
@endscope
</programlisting>

Again, it is recommended for the reader to guess what this prints, and only
afterwards run it.

</para><para>

The built-ins specified by @ are different: they are not defined in any scope
but are built-ins instead. Function pointers to built-ins cannot be done, but
it's always possible to create a function which only calls a built-in and
then create function pointers to the call-built-in function:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $STRREVERSE($ARG)
  @return @strreverse($ARG)
@endfunction

$FUNPOINTER1=$STRREVERSE

@beginscope
  $FUNPOINTER2=$STRREVERSE
  @call @dump($FUNPOINTER1("abc"))
  @call @dump($FUNPOINTER2("abc"))
@endscope
</programlisting>

</para>
    </sect1>
  </chapter>
  <chapter xml:id="commands">
    <title>How Stirmake executes its commands</title>
    <sect1>
      <title>Different ways of executing commands</title>
<para>

Make executes its commands always via the Bourne shell /bin/sh. Stirmake can
either use the shell or omit its use, at the Stirfile author's preference.

</para><para>

The same syntax that is used in make too executes the command after tabulator
via shell:

<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
	cc -o $@ $&lt;
</programlisting>

</para><para>

In this case, the command is sh -c "cc -o $@ $&lt;". To omit shell and invoke
the compiler directly, you can use the @-tab syntax, which takes a list of
command-line arguments:

<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	["cc", "-o", $@, $&lt;]
</programlisting>

</para><para>

Also sometimes you may want to include more than one command in a single
line. It is possible with the @@-tab syntax:

<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'libhello.a': 'hello.o'
@@	[["rm", "-f", $@], ["ar", "rvs", $@, @@suffilter($^, ".o")]]
</programlisting>

In this case, after the tabulator you have an array of arrays of strings, not a
simple array of strings.

</para>
    </sect1>
    <sect1>
      <title>The dangers of shell expansion</title>
<para>

Shell expansion may not always do what you want. Firstly, spaces in file names
cause the file name to be split to multiple command-line arguments. The shell
also assigns special meanings to many characters like `, \ and $. Stirmake does
not have any attempt at shell escaping to support for example dollar signs
in file names. Stirmake's way to allow dollar signs in file names is to not use
shell, but instead invoke the compiler directly with no shell inbetween.

</para>
    </sect1>
    <sect1>
      <title>Invoking shell manually</title>
<para>

Of course, with the @-tab syntax it's possible to specify the shell manually:

<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'hello'
'hello': 'hello.c'
@	["sh", "-c", "cc -o " . $@ . " " . $&lt;]
</programlisting>

</para><para>

Note that the -c option takes only one argument, so everything has to be
concatenated to a string with space as argument delimiter.

</para>
    </sect1>
    <sect1>
      <title>Build command, timestamp and file size database</title>
<para>

Stirmake has database which tells what commands have been executed to create
the targets, and full timestamp and file size information for the targets. This
default mode is used whenever -e is not specified as the command line argument.
The uppercase -E on the other hand explicitly turns on this default mode. If
-e is used, the database contains only build commands but not file timestamps
and file sizes. The version of database is in this case @v1@.

</para><para>

An example of the database when -E is used:
<programlisting>
@v2@

"." "prog":
	"NI" "E" "NM" "cc" "-Wall" "-O3" "-o" "prog" "hello.o"

"." "hello.o":
	"NI" "E" "NM" "cc" "-Wall" "-O3" "-c" "-o" "hello.o" "hello.c"

"." "hello.d":
	"NI" "E" "NM" "cc" "-Wall" "-O3" "-MM" "-o" "hello.d" "hello.c"

"hello.d" = 17 1759334220 851355669

"hello.c" = 27 1759334155 483267579

"hello.o" = 1456 1759334220 879355707

"prog" = 16464 1759334220 895355729
</programlisting>

</para><para>

The @v2@ specifier at beginning tells the version (v1: just commands, v2: also
file sizes and timestamps). The first three files are mentioned along with the
commands that were used to build the files. The first "NI", "E", "NM" are
command settings (no-ignore / ignore, echo / no-echo, no-make / is-make) and
the rest is the command that was used.

</para><para>

The last four files are mentioned along with their sizes in bytes and the
modification timestamp of the files. If the file size or timestamp differs,
it can be concluded that rebuild is necessary.

</para>
    </sect1>
    <sect1>
      <title>Move madness</title>
<para>

Let us assume that you have the following Makefile:

<programlisting>
hello: hello.c
	cc -o hello hello.c
</programlisting>

</para><para>

You want to take a backup of hello.c before you start modifying it. Then you
modify it and run "make". Then for some reason you want to restore the old
unmodified version. Then you run "make", and find that "make" won't build
anything:
<programlisting>
cp hello.c hello.c.bak
$EDITOR hello.c
make
mv hello.c.bak hello.c
make
</programlisting>

</para><para>

In this case, the cp command creates a new timestamp for the copy, but it's
before the timestamp of edited hello.c and before the timestamp of the binary
hello which make created. However, mv is different from cp. Whereas cp creates
a new timestamp, mv does a rename and doesn't touch the timestamp. Therefore,
after the mv command, hello.c timestamp and possibly file size did change, but
it didn't become newer than the timestamp of the hello binary. Therefore, with
standard make, hello won't be rebuilt. This anomaly can be called
<emphasis>move madness</emphasis>.

</para><para>

Stirmake is immune to move madness, since stirmake has a file size, command
and timestamp database. In this example of move madness, at least the timestamp
of hello.c did change although it didn't become newer than the timestamp of
hello binary. Also it's possible the file size changed. In this case, stirmake
has enough information to conclude that the file has in fact changed, and
does a rebuild.

</para>
    </sect1>
    <sect1>
      <title>Command options: ignore, noecho, ismake, automatic make detection</title>
<para>

Stirmake supports three command options: @ignore, @noecho and @ismake.

</para><para>

Normally, all commands that stirmake executes are echoed to standard output,
unless the -s (silent) option is given as argument. However, individual command
echoing can be disabled with @noecho. This is useful if the list of commands
has an "echo" command, which would then be echoed twice: first the full command
name, then the argument to "echo". How to do this:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@	@noecho ["echo", "foo"]
</programlisting>

</para><para>

Also, normally, a command that fails stops the build process. All commands must
return "true" exit status, 0, not "false" (which would be nonzero). To allow
command returning false to not stop the build, use @ignore:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@	@ignore ["false"]
@	@noecho ["echo", "false was ignored"]
</programlisting>

</para><para>

Stirmake needs to know if the sub-process it executes is GNU make. The reason
being that GNU make requires a jobserver, which stirmake has to offer via
environment variables. Normally, stirmake compares the program name with a
built-in list of known GNU make names:
<itemizedlist>
<listitem>make</listitem>
<listitem>gmake</listitem>
<listitem>/usr/bin/make</listitem>
<listitem>/usr/bin/gmake</listitem>
<listitem>/usr/local/bin/make</listitem>
<listitem>/usr/local/bin/gmake</listitem>
<listitem>/usr/pkg/bin/make</listitem>
<listitem>/usr/pkg/bin/gmake</listitem>
<listitem>/opt/bin/make</listitem>
<listitem>/opt/bin/gmake</listitem>
<listitem>/opt/gnu/bin/make</listitem>
<listitem>/opt/gnu/bin/gmake</listitem>
<listitem>/bin/make</listitem>
<listitem>/bin/gmake</listitem>
</itemizedlist>

However, if GNU make is invoked with a command that is not present in this
list, it is possible to mark the command as GNU make with @ismake:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@	@ismake ["/opt/bin/gnumake", "-C", "subdir"]
</programlisting>

</para>
    </sect1>
    <sect1>
      <title>@glob and the dangers of @glob in middle of many commands</title>
<para>

Stirmake has a feature @glob to evaluate shell glob patterns, using the glob()
interface without actually invoking the shell. However, its usage is somewhat
limited as a list of commands has to have all commands evaluated before the
commands can be executed, because stirmake has command database and needs to
compare the current list of commands against the list as of previous
invocation.

</para><para>

Consider for example that you have a zip file and you want to unzip it but
remove all text files:

<programlisting>
@toplevel
@strict
@phonyrule: 'unzip': 'zip.zip'
@	["unzip", "zip.zip"]
@	["rm", @@glob("*.txt")]
</programlisting>

Now the question is, how does this work? Does it execute @glob before or after
unzip? The unfortunate news is that stirmake has to have full knowledge of the
build commands before they can be executed, because if the list is equal to
the previous list of commands and if none of the files have been changed, it
is pointless to invoke the commands. So, the @glob has to be executed before
unzip is called. Therefore, the list of text files does not have any text files
that were created by unzipping the archive.

</para><para>

This problem can be avoided by using the shell:

<programlisting>
@toplevel
@strict
@phonyrule: 'unzip': 'zip.zip'
@	["unzip", "zip.zip"]
@	["sh", "-c", "rm *.txt"]
</programlisting>

Now since the glob evaluation result isn't part of the command, this works fine
since stirmake doesn't have to evaluate *.txt but rather the shell evaluates
it. What *.txt evaluates to, isn't part of the build command database.

</para><para>

Where glob is useful is for example automatic creation of rules from .c to .d
and .o:
<programlisting>
@toplevel
@strict
$CC="cc"
$CFLAGS=["-Wall", "-O3"]
$SRC=@glob("*.c")
$DEP=@sufsuball($SRC, ".c", ".d")
$OBJ=@sufsuball($SRC, ".c", ".o")
'prog': $(OBJ)
@	[$CC, @$CFLAGS, "-o", $@, @@suffilter($^, ".o")]
@patrule: $(OBJ): '%.o': '%.c' '%.d'
@	[$CC, @$CFLAGS, "-c", "-o", $@, $&lt;]
@patrule: $(DEP): '%.d': '%.c'
@	[$CC, @$CFLAGS, "-MM", "-o", $@, $&lt;]
@cdepincludes @autophony @autotarget @ignore $DEP
</programlisting>

In this example, the Stirfile does not need to be modified whenever a new
.c file is created to the directory. It is up to the reader to decide whether
this feature in Stirfile is good, or whether Stirfile should have an explicit
list of what to compile.

</para>
    </sect1>
    <!-- tab, at-tab, at-at-tab -->
    <!-- the dangers of shell expansion -->
    <!-- shell can still be manually invoked -->
    <!-- build command and file size database -->
    <!-- move madness -->
    <!-- ignore -->
    <!-- noecho -->
    <!-- ismake and automatic make detection -->
    <!-- @glob and dangers of @glob in the middle of many commands -->
  </chapter>
  <chapter xml:id="cleaning">
    <title>Automated cleaning with stirmake</title>

    <sect1>
      <title>Automated cleaning</title>

<para>

Stirmake supports automated cleaning with the options -b and -c. The option
-b cleans only files that have been marked distributables (@distrule), whereas
the option -c cleans only files that have not been marked distributables. If
you want to clean everything, you need to use both and run smka -bc.

</para><para>

It is possible to use "smkt -bc" to clean all files in the current directory,
not all files in all directories. Similarly, "smkt -b" and "smkt -c" work to
clean only files of the desired type only in the current directory.

</para>

    </sect1>
    <sect1>
      <title>Hooks</title>
<para>
By default, stirmake decides what files need removing when cleaned. However,
sometimes you may want to add hooks for doing additional actions when cleaning.
This is supported by:

<programlisting>
@toplevel
@strict

@cleanhook:
@	["echo", "cleanhook"]

@distcleanhook:
@	["echo", "distcleanhook"]

@bothcleanhook:
@	["echo", "bothcleanhook"]

@phonyrule: 'all':
@	["echo", "all"]
</programlisting>

</para><para>

Now if you type "smka -c" the cleanhook is executed. If you type "smka -b", the
distcleanhook is executed. If you type "smka -bc", then bothcleanhook is
executed. If you type "smka" without anything, then the first ordinary rule,
"all", is executed.

</para><para>

There cannot be multiple hooks:
<programlisting>
@toplevel
@strict

@cleanhook:
@	["echo", "cleanhook"]

@cleanhook:
@	["echo", "anothercleanhook"]

@phonyrule: 'all':
@	["echo", "all"]
</programlisting>
...which, when called with "smka" will say the hook already exists. However,
each subdirectory may have its own hooks.

</para><para>

If interfacing to a sub-make that supports cleaning object files and all files
but not cleaning only binaries, it's possible to add a hook that fails:

<programlisting>
@toplevel
@strict

@cleanhook:
@	["echo", "cleanhook"]

@distcleanhook:
@	["false"]

@bothcleanhook:
@	["echo", "bothcleanhook"]

@phonyrule: 'all':
@	["echo", "all"]
</programlisting>
...and now "smka -b" does not work.

</para>

    </sect1>

    <!-- distrule and disttgt -->
  </chapter>
  <chapter xml:id="conditional">
    <title>Conditional compilation</title>
<para>

One of the basic features of stirmake is conditional compilation. Both rules
and additional dependencies can be put inside top-level @if statements. Also if
you use pattern rules, they need to be instantiated by an array of filenames,
and obviously that array can be modified inside @if statements.

</para><para>

An example of conditional compilation with pattern rules:

<programlisting>
@toplevel
@strict
$IS_ARM=@false
$MACHINE `= ["cc", "-dumpmachine"]
$MACHINE = @chomp($MACHINE)
@if(@strcmp(@substr($MACHINE, 0, 4), "arm-") == 0)
$IS_ARM=@true
@endif

$OBJS = ["file1.o", "platformindependent.o"]
@if($IS_ARM)
$OBJS += ["armneonimpl.o"]
@endif

@phonyrule: 'all': 'libcommon.a'

@patrule: $OBJS: '%.o': '%.c'
@	["cc", "-c", "-o", $@, $&lt;]

'libcommon.a': $(OBJS)
@	["rm", "-f", $@]
@	["ar", "rvs", $@, @@suffilter($^, ".o")]
</programlisting>

In this case, if the "cc -dumpmachine" command prints arm-linux-gnueabihf, or
something else that begins with arm-, the file armneonimpl.o is compiled in.

</para><para>

Also, entire rules and additional dependencies specified with @deponly can be
inside top-level @if statements:

<programlisting>
@toplevel
@strict
$IS_ARM=@false
$MACHINE `= ["cc", "-dumpmachine"]
$MACHINE = @chomp($MACHINE)
@if(@strcmp(@substr($MACHINE, 0, 4), "arm-") == 0)
$IS_ARM=@true
@endif

@phonyrule: 'all': 'libcommon.a'

$OBJS = ["file1.o", "platformindependent.o"]
@patrule: $OBJS: '%.o': '%.c'
@	["cc", "-c", "-o", $@, $&lt;]

@if($IS_ARM)
'armneonimpl.o': 'armneonimpl.c'
@	["cc", "-c", "-o", $@, $&lt;]
@deponly: 'libcommon.a': 'armneonimpl.o'
@endif


'libcommon.a': $(OBJS)
@	["rm", "-f", $@]
@	["ar", "rvs", $@, @@suffilter($^, ".o")]
</programlisting>

</para>
  </chapter>
  <chapter xml:id="exampleprojects">
    <title>Example projects</title>
    <sect1>
      <title>mploop</title>
<para>

<link xlink:href="https://github.com/jmtilli/mploop">mploop</link> is perhaps
the simplest project that can be compiled with Stirmake. The main program is
written in Python and thus requires no compilation, but there is also
mploopplayer, written in C, in a single C file.

</para><para>

The top-level Stirfile contains:

<programlisting>
@toplevel
@strict

$CC = "cc"
$CFLAGS = ["-Wall", "-Wextra", "-O3", "-g"]

@phonyrule: 'all': 'mploopplayer/all'

@dirinclude ["mploopplayer"]
</programlisting>

And the subfile mploopplayer/Stirfile contains:
<programlisting>
@subfile
@strict

$LIBS = ["-lavformat", "-lavcodec", "-lavutil", "-lSDL2", "-lm"]

@phonyrule: 'all': 'mploopplayer'

@distrule: 'mploopplayer': 'mploopplayer.c'
@	[$(CC), "-o", "mploopplayer", "mploopplayer.c", @$(CFLAGS), @$(LIBS)]
</programlisting>

It is important to note here that the top-level Stirfile needs to contain
at least the phonyrule all, since without rules, smka will not do anything.
The subfile contains rule referenced as mploopplayer/all from top-level but as
all from subfile.

</para>
    </sect1>
    <sect1>
      <title>quictest</title>
<para>

<link xlink:href="https://github.com/jmtilli/quictest">quictest</link> contains
testing code to extract server name indication from initial QUIC packets. A
peculiarity of it is that some files use AES-NI instructions and need
additional compiler flags. No subdirectories are used.

</para><para>

The Stirfile is as follows:

<programlisting>
@toplevel
@strict

$CC ?= "cc"
$CFLAGS ?= ["-O4", "-g", "-std=gnu11"]
$CFLAGS_NI ?= ["-march=skylake", "-msse", "-msse2", "-msse3", "-mssse3", "-msse4", "-msse4.1", "-msse4.2", "-mavx", "-mavx2"]
$LDFLAGS ?= []

$SOURCES = ["aes.c", "aestest.c", "hkdf.c", "hkdftest.c", "quictest.c", "sha_hp.c", "sha_pd.c", "rbtree.c"]
$SOURCES_NI = ["aes_aesni.c"]
$OBJS = @sufsuball($SOURCES, ".c", ".o")
$DEPS = @sufsuball($SOURCES, ".c", ".d")
$OBJS_NI = @sufsuball($SOURCES_NI, ".c", ".o")
$DEPS_NI = @sufsuball($SOURCES_NI, ".c", ".d")

@phonyrule: 'all': 'aestest' 'hkdftest' 'quictest'

'aestest': 'aestest.o' 'aes.o' 'aes_aesni.o'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

'quictest': 'quictest.o' 'aes.o' 'aes_aesni.o' 'hkdf.o' 'sha_hp.o' 'sha_pd.o' 'rbtree.o'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

'hkdftest': 'hkdftest.o' 'hkdf.o' 'sha_hp.o' 'sha_pd.o'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

@patrule: $(OBJS): '%.o': '%.c' '%.d'
@	[$(CC), @$(CFLAGS), "-c", "-o", $@, $&lt;]

@patrule: $(DEPS): '%.d': '%.c'
@	[$(CC), @$(CFLAGS), "-MM", "-o", $@, $&lt;]

@patrule: $(OBJS_NI): '%.o': '%.c' '%.d'
@	[$(CC), @$(CFLAGS), @$(CFLAGS_NI), "-c", "-o", $@, $&lt;]

@patrule: $(DEPS_NI): '%.d': '%.c'
@	[$(CC), @$(CFLAGS), @$(CFLAGS_NI), "-MM", "-o", $@, $&lt;]

@cdepincludes @autophony @autotarget @ignore [@$(DEPS), @$(DEPS_NI)]
</programlisting>

</para>
    </sect1>
    <sect1>
      <title>steamingatof</title>
<para>

<link
xlink:href="https://github.com/jmtilli/streamingatof">streamingatof</link> is
very simple, it contains only one program and one library file. The Stirfile is
as follows:

<programlisting>
@toplevel
@strict

@fileinclude @ignore "opts.smk"

$CC ?= "cc"
$CFLAGS ?= ["-g", "-O2", "-Wall", "-Wextra", "-Wsign-conversion", "-Wno-missing-field-initializers", "-Wno-unused-parameter", "-Wshadow", "-Wstrict-prototypes", "-Wmissing-prototypes", "-Wpointer-arith", "-Werror", "-std=gnu11", "-fPIC"]

$(SRC_LIB) = ["streamingatof.c"]
$(SRC_PROG) = ["test.c"]

$(SRC) = [@$(SRC_LIB), @$(SRC_PROG)]
$(OBJ_LIB) = @sufsuball($(SRC_LIB), ".c", ".o")
$(OBJ) = @sufsuball($(SRC), ".c", ".o")
$(DEP) = @sufsuball($(SRC), ".c", ".d")
$(PROG) = @sufsuball($(SRC_PROG), ".c", "")

@phonyrule: 'all': 'libstreamingatof.a' $(PROG)

@patrule: $(PROG): '%': '%.o' 'libstreamingatof.a'
@	[$(CC), @$(CFLAGS), "-o", $@, $&lt;, 'libstreamingatof.a']

@patrule: $(OBJ): '%.o': '%.c' '%.d'
@	[$(CC), @$(CFLAGS), "-c", "-o", $@, $&lt;]

@patrule: $(DEP): '%.d': '%.c'
@	[$(CC), @$(CFLAGS), "-MM", "-o", $@, $&lt;]

'libstreamingatof.a': $(OBJ_LIB)
@	["rm", "-f", $@]
@	["ar", "rvs", $@, @@suffilter($^, ".o")]

@phonyrule: 'unit': 'test'
@	["./test"]

@cdepincludes @autophony @autotarget @ignore [@$(DEP)]
</programlisting>

An option to include possible opts.smk to change options is present. Also note
the phonyrule unit which executes unit tests.

</para>
    </sect1>
    <sect1>
      <title>prettyftoa</title>
<para>

<link xlink:href="https://github.com/jmtilli/prettyftoa">prettyftoa</link> is
very similar to streamingatof. It contains one library file and one unit test
program. The Stirfile is as follows:

<programlisting>
@toplevel
@strict

@fileinclude @ignore "opts.smk"

$CC ?= "cc"
$CFLAGS ?= ["-g", "-O2", "-Wall", "-Wextra", "-Wsign-conversion", "-Wno-missing-field-initializers", "-Wno-unused-parameter", "-Wshadow", "-Wstrict-prototypes", "-Wmissing-prototypes", "-Wpointer-arith", "-Werror", "-std=gnu11", "-fPIC"]

$(SRC_LIB) = ["prettyftoa.c"]
$(SRC_PROG) = ["test.c"]

$(SRC) = [@$(SRC_LIB), @$(SRC_PROG)]
$(OBJ_LIB) = @sufsuball($(SRC_LIB), ".c", ".o")
$(OBJ) = @sufsuball($(SRC), ".c", ".o")
$(DEP) = @sufsuball($(SRC), ".c", ".d")
$(PROG) = @sufsuball($(SRC_PROG), ".c", "")

@phonyrule: 'all': 'libprettyftoa.a' $(PROG)

@patrule: $(PROG): '%': '%.o' 'libprettyftoa.a'
@	[$(CC), @$(CFLAGS), "-o", $@, $&lt;, 'libprettyftoa.a']

@patrule: $(OBJ): '%.o': '%.c' '%.d'
@	[$(CC), @$(CFLAGS), "-c", "-o", $@, $&lt;]

@patrule: $(DEP): '%.d': '%.c'
@	[$(CC), @$(CFLAGS), "-MM", "-o", $@, $&lt;]

'libprettyftoa.a': $(OBJ_LIB)
@	["rm", "-f", $@]
@	["ar", "rvs", $@, @@suffilter($^, ".o")]

@phonyrule: 'unit': 'test'
@	["./test"]

@cdepincludes @autophony @autotarget @ignore [@$(DEP)]
</programlisting>

</para>
    </sect1>
    <sect1>
      <title>rlctrans</title>
<para>

<link xlink:href="https://github.com/jmtilli/rlctrans">rlctrans</link> contains
one library file and a huge number of programs that utilize the library. The
Stirfile is as follows:

<programlisting>
@toplevel
@strict

$SRC_LIB=["libsimul.c"]
$SRC_PROG=["buck.c", "buckramp.c", "buckgood.c", "inverterpwm.c", "rectifier.c", "transformer.c", "forward.c", "forwardgood.c", "flyback.c", "flybackgood.c", "pfcboost.c", "rectifier3.c", "pfc3.c", "inverterpwm3.c", "pfcsimple3.c", "shockleyrectifier.c", "boostgood.c", "buckboostgood.c"]
$PROG=@sufsuball($SRC_PROG, ".c", "")
$SRC=[@$SRC_LIB, @$SRC_PROG]
$OBJ=@sufsuball($SRC, ".c", ".o")
$OBJ_LIB=@sufsuball($SRC_LIB, ".c", ".o")
$DEP=@sufsuball($SRC, ".c", ".d")
$CC="cc"
$AR="ar"
$RM="rm"
$CFLAGS=["-Wall", "-O3", "-g"]
$LIBS=["-llapack", "-lm"]

@phonyrule: 'all': $PROG

@patrule: $OBJ: '%.o': '%.c' '%.d'
@	[$CC, @$CFLAGS, "-c", "-o", $@, $&lt;]

@patrule: $DEP: '%.d': '%.c'
@	[$CC, @$CFLAGS, "-M", "-o", $@, $&lt;]

'libsimul.a': $OBJ_LIB
@	[$RM, "-f", $@]
@	[$AR, "rvs", $@, @$^]

@patrule: $PROG: '%': '%.o' 'libsimul.a'
@	[$CC, "-o", $@, @@suffilter($^, ".o"), @@suffilter($^, ".a"), @$LIBS]

@cdepincludes @autophony @autotarget @ignore $DEP
</programlisting>

</para>
    </sect1>
    <sect1>
      <title>jmalloc</title>
<para>

<link xlink:href="https://github.com/Aalto5G/jmalloc">jmalloc</link> contains
several programs and a subdirectory realapp:

<programlisting>
@toplevel
@strict

$CC ?= "cc"
$CFLAGS ?= ["-O3"]
$LDFLAGS ?= []

@phonyrule: 'all': 'jmalloc2' 'jmalloc' 'lmalloc' 'jmalloc2complex' 'lmalloccomplex' 'realapp/all'

'jmalloc2': 'jmalloc2.c'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

'jmalloc': 'jmalloc.c'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

'lmalloc': 'lmalloc.c'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

'jmalloc2complex': 'jmalloc2complex.c'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

'lmalloccomplex': 'lmalloccomplex.c'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

@dirinclude 'realapp'
</programlisting>

The realapp/Stirfile subfile is as follows:
<programlisting>
@subfile
@strict

@phonyrule: 'all': 'allocreal' 'allocstd' 'allocrealset' 'allocstdset'

$CC ?= "cc"
$CFLAGS ?= ["-O3"]
$LDFLAGS ?= []

'ops.c': 'allocanalyze.py' 'allocs.txt'
@	["sh", "-c", "python allocanalyze.py ops > ops.c"]

'allocreal.c': 'allocanalyze.py' 'allocs.txt'
@	["sh", "-c", "python allocanalyze.py jm > allocreal.c"]

'allocrealset.c': 'allocanalyze.py' 'allocs.txt'
@	["sh", "-c", "python allocanalyze.py jmset > allocrealset.c"]

'allocstd.c': 'allocanalyze.py' 'allocs.txt'
@	["sh", "-c", "python allocanalyze.py std > allocstd.c"]

'allocstdset.c': 'allocanalyze.py' 'allocs.txt'
@	["sh", "-c", "python allocanalyze.py stdset > allocstdset.c"]

'allocreal.o': 'allocreal.c'
@	["cc", @$CFLAGS, "-c", "-o", $@, $&lt;]

'allocstd.o': 'allocstd.c'
@	["cc", @$CFLAGS, "-c", "-o", $@, $&lt;]

'allocrealset.o': 'allocrealset.c'
@	["cc", @$CFLAGS, "-c", "-o", $@, $&lt;]

'allocstdset.o': 'allocstdset.c'
@	["cc", @$CFLAGS, "-c", "-o", $@, $&lt;]

'ops.o': 'ops.c'
@	["cc", @$CFLAGS, "-c", "-o", $@, $&lt;]

'jmalloccore.o': 'jmalloccore.c'
@	["cc", @$CFLAGS, "-c", "-o", $@, $&lt;]

'allocreal': 'allocreal.o' 'jmalloccore.o' 'ops.o'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

'allocstd': 'allocstd.o' 'jmalloccore.o' 'ops.o'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

'allocrealset': 'allocrealset.o' 'jmalloccore.o' 'ops.o'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]

'allocstdset': 'allocstdset.o' 'jmalloccore.o' 'ops.o'
@	["cc", @$CFLAGS, @$LDFLAGS, "-o", $@, @$^]
</programlisting>

</para><para>

It is evident from the subfile that there is some repetition that could be
eliminated easily. Also, note that shell redirections require actually invoking
the Bourne shell with the command "sh -c".

</para>
    </sect1>
    <sect1>
      <title>abce</title>
<para>

By far, the most complex Stirfile of these examples is the stirfile of <link
xlink:href="https://github.com/Aalto5G/abce">abce</link>. It takes commands
and flags $CC, $CFLAGS, $FLEX and $BYACC from the parent Stirfile (it is
designed to be includable in Stirfiles of other projects), with fallback to
environment and if they have not been defined either in parent Stirfile or
environment, default commands and flags are used. There is also option to
compile it with Lua support, not used as default.

The Stirfile of abce is as follows:

<programlisting>
@toplevel
@strict

# You can modify these during compilation
$(CC) ?= @nil
@if(@type($(CC)) == @type(@nil))
  $(CC) ``= ["sh", "-c", "echo $CC"]
  @if($(CC)[] == 0)
    $(CC) = ["cc"]
  @endif
@endif
$(CFLAGS) ?= @nil
@if(@type($(CFLAGS)) == @type(@nil))
  $(CFLAGS) ``= ["sh", "-c", "echo $CFLAGS"]
  @if($(CFLAGS)[] == 0)
    $(CFLAGS) = ["-O3", "-Wall", "-g"]
  @endif
@endif
$(FLEX) ?= @nil
@if(@type($(FLEX)) == @type(@nil))
  $(FLEX) ``= ["sh", "-c", "echo $FLEX"]
  @if($(FLEX)[] == 0)
    $(FLEX) = ["flex"]
  @endif
@endif
$(BYACC) ?= @nil
@if(@type($(BYACC)) == @type(@nil))
  $(BYACC) ``= ["sh", "-c", "echo $BYACC"]
  @if($(BYACC)[] == 0)
    $(BYACC) = ["byacc"]
  @endif
@endif
$(WITH_LUA) ?= @false
$(LUAINCS) ?= ["-I/usr/include/luajit-2.1"]
$(LUALIBS) ?= ["/usr/lib/x86_64-linux-gnu/libluajit-5.1.a"]

# You can modify these during development
$(SRC_LIB) = ["amyplanyyutils.c", "memblock.c", "abcerbtree.c", \
              "amyplanlocvarctx.c", "engine.c", "abcestring.c", "abcetrees.c", \
              "abcescopes.c", "abce.c", "abceapi.c", "safemode.c", \
              "abcejmalloc.c", "abceprettyftoa.c", "abce_caj_out.c", \
              "abcestreamingatof.c", "abce_caj.c"]
$(SRC_PROG) = ["gctest.c", "reftest.c", "ret.c", "breaktest.c", "main.c", \
               "locvartest.c", "treetest.c", "amyplantest.c", "fiboefftest.c", \
               "fortest.c", "iftest.c", "dumptest.c", "fibonaccitest.c", \
               "bttest.c", "shortcut.c", "dictnext.c", "amyplan.c", \
               "getenvtest.c"]
$(LEX_LIB) = ["amyplanyy.l"]

# Here starts the portions you probably don't want to modify
$(YACC_LIB) = @sufsuball($(LEX_LIB), ".l", ".y")
$(SRC) = [@$(SRC_LIB), @$(SRC_PROG)]
$(LEXGEN_LIB) = @sufsuball($(LEX_LIB), ".l", ".lex.c")
$(YACCGEN_LIB) = @sufsuball($(YACC_LIB), ".y", ".tab.c")
$(GEN_LIB) = [@$(LEXGEN_LIB), @$(YACCGEN_LIB)]
$(OBJ_LIB) = @sufsuball($(SRC_LIB), ".c", ".o")
$(OBJ) = @sufsuball($(SRC), ".c", ".o")
$(OBJGEN_LIB) = @sufsuball($(GEN_LIB), ".c", ".o")
$(DEP) = @sufsuball($(SRC), ".c", ".d")
$(DEPGEN_LIB) = @sufsuball($(GEN_LIB), ".c", ".d")
$(PROG) = @sufsuball($(SRC_PROG), ".c", "")

@if(!$(WITH_LUA))
  $(LUAINCS) = []
  $(LUALIBS) = []
@endif
@if($(WITH_LUA))
  $(CFLAGS) = [@$(CFLAGS), @$(LUAINCS), "-DWITH_LUA"]
@endif

@phonyrule: 'all': $(PROG) 'libabce.a'

@phonyrule: 'wc':
@	["wc", "-l", @$(LEX_LIB), @$(YACC_LIB), @$(SRC), @@suffilterout(@suffilterout(@glob("*.h"),".lex.h"),".tab.h")]

@patrule @distrule: $(PROG): '%': '%.o' 'libabce.a'
@	[@$(CC), @$(CFLAGS), "-o", $@, $&lt;, 'libabce.a', @$(LUALIBS), '-lm', '-ldl']

@patrule: $(OBJ): '%.o': '%.c' '%.d'
@	[@$(CC), @$(CFLAGS), "-c", "-o", $@, $&lt;]

@patrule: $(OBJGEN_LIB): '%.o': '%.c' '%.h' '%.d'
@	[@$(CC), @$(CFLAGS), "-Wno-sign-compare", "-Wno-missing-prototypes", "-c", "-o", $@, $&lt;]

@patrule: $(DEP): '%.d': '%.c'
@	[@$(CC), @$(CFLAGS), "-MM", "-o", $@, $&lt;]

@patrule: $(DEPGEN_LIB): '%.d': '%.c' '%.h'
@	[@$(CC), @$(CFLAGS), "-Wno-sign-compare", "-Wno-missing-prototypes", "-MM", "-o", $@, $&lt;]

'libabce.a': $(OBJ_LIB) $(OBJGEN_LIB)
@	["rm", "-f", $@]
@	["ar", "rvs", $@, @@suffilter($^, ".o")]

@function $ADD_LEXX_YACC_DEPS($lex)
  @locvar $b = @sufsuball($lex, ".l", "")
  @locvar $i = 0
  @locvar $c = @nil
  @for($i = 0, $i &lt; $b[], $i = $i+1)
    $c = $b[$i]
    @adddeps([$c.".lex.d", $c.".lex.o", $c.".tab.d", $c.".tab.o"], \
             [$c.".lex.h", $c.".tab.h"], {})
  @endfor
@endfunction
@call $ADD_LEXX_YACC_DEPS($(LEX_LIB))

@patrule: $(LEXGEN_LIB): '%.lex.c' '%.lex.h': '%.l'
@	[@$(FLEX), "--outfile=".$@, "--header-file=".@sufsubone($@,".c",".h"), \
	$&lt;]

@patrule: $(YACCGEN_LIB): '%.tab.c' '%.tab.h': '%.y'
@	[@$(BYACC), "-d", "-p", @sufsubone($@, ".tab.c", ""), "-b", \
	@sufsubone($@, ".tab.c", ""), "-o", $@, $&lt;]

@cdepincludes @autophony @autotarget @ignore [@$(DEP), @$(DEPGEN_LIB)]
</programlisting>

</para>
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_stirmakelargescale">
  <title>Stirmake in large-scale systems</title>
  <chapter xml:id="multiproject">
    <title>Stirmake for entire project structures</title>
    <sect1>
      <title>Including sub-projects</title>
<para>

Previously, @dirinclude to include subdirectories was demonstrated. This is
intended for cases where the included subdirectory belongs to the same project,
i.e. same git repository. The included sub-Stirfile must have @subfile in
the first line.

</para><para>

However, git submodules are projects that can be built separately or as part
of the parent module. Because they can be built separately, they cannot have
@subfile in the first line; rather, they must have @toplevel. Including a
@toplevel Stirfile with @dirinclude does not work. In this case, the project
would be included with @projdirinclude:

<programlisting>
@toplevel
@strict

@phonyrule: 'all': 'subproj/all'

@projdirinclude 'subproj'
</programlisting>

The subproj Stirfile would then start with @toplevel too.

</para>
    </sect1>
    <sect1>
      <title>Invoking stirmake: smka, smkp, smkt</title>
<para>

Stirmake can be invoked using three commands: smka (equal to stirmake -a), smkp
(equal to stirmake -p), and smkt (equal to stirmake -t). The last characters
mean "all", "(this) project", "this directory".

</para><para>

Let us suppose that you have a parent project named "parent", with
sub-directory "parent/subdir", and a sub-project "parent/subdir/subproj", and a
sub-directory "parent/subdir/subproj/subdir2". If you are currently in the
directory "parent/subdir/subproj/subdir2", then you may invoke stirmake in
the following ways:

<itemizedlist mark="bullet">
<listitem><para>smkt ../all</para></listitem>
<listitem><para>smkp all</para></listitem>
<listitem><para>smka subdir/subproj/all</para></listitem>
</itemizedlist>

All of them refer to the target all in the Stirfile "subdir/subproj/Stirfile".
If smkt, smkp or smka are executed without arguments in the same directory
"parent/subdir/subproj/subdir2", "smkt" would execute the first target of
parent/subdir/subproj/subdir2/Stirfile", "smkp" would execute the first target
of parent/subdir/subproj/Stirfile", and "smka" would execute the first target
of the top-level parent/Stirfile. Usually the first target is named "all" by
convention, and the rule is a phony rule, but this is not certain in all cases.

</para><para>

Note how Stirmake is superior to make in this aspect. You may execute "smka" in
any subdirectory and it will build everything in the whole project structure.
With inclusive make, this is not possible, and "make" must be executed in the
top-level directory that contains a Makefile and not in a subdirectory that
contains module.mk. Note also that with recursive "make", if you execute "make"
in a subdirectory, it does not build its dependencies, and if the dependencies
are alreayd built and the build of the subdirectory succeeds, you still can't
be certain that the interface wasn't changed in a manner that would cause build
of some other subdirectory (and thus a top-level build of everything) to fail.
Stirmake is similar to git: you can execute "git status" or any other git
command in any subdirectory, and it will work.

</para>
    </sect1>
    <sect1>
      <title>Controlling what to export with holey scopes</title>
<para>

Stirmake uses recursive scoping, where if the variable $(CC) is accessed, it
accesses first $(CC) in the current scope (lexical or dynamic specified by @L
or @D before the variable name), then its parent scope, then its grandparent
scope, etc. until there are no longer any parent scopes. This means that if you
have a complex Stirfile and include a subproject, everything in the parent
scope is visible to the subproject. This may not be optimal in all cases. It
may be useful to be able to specify what variables are visible to the
subproject.

</para><para>

This is possible with @beginholeyscope and @endscope. A holey scope is a scope
that terminates the recursive scoping so that the parent scope is not accessed
by default, but the lexical or dynamic parent scope can still be explicitly
accessed with @LP or @DP.

</para><para>

Example from Stirfile of stirmake:

<programlisting>
@beginholeyscope
  $(CC) = @LP$(CC)
  $(CFLAGS) = @LP$(CFLAGS)
  $(WITH_LUA) = @LP$(WITH_LUA)
  $(LUAINCS) = @LP$(LUAINCS)
  $(LUALIBS) = @LP$(LUALIBS)
  $(FLEX) = @LP$(FLEX)
  $(BYACC) = @LP$(BYACC)
  @projdirinclude "abce"
@endscope
</programlisting>

In this case, the subproject abce sees only $CC, $CFLAGS, $WITH_LUA, $LUAINCS,
$LUALIBS, $FLEX and $BYACC and all other variables are left undefined.  The
variables are taken from the scope of the Stirfile in which @beginholeyscope is
defined. Note how @LP avoids the recursion break of @beginholeyscope, by
accessing the parent scope (or the grandparent scope or the parent of
grandparent, etc.).

</para><para>

If you want to access the lexical parent scope without recursion to
grandparent, or the dynamic parent scope without recursion to grandparent, you
can do so with @LPO or @DPO. Similarly, you can access the lexical or dynamic
scope without recursion to parent scope by @LO and @DO. All scope type
specifiers with character O terminate recursion, and character P mean "access
parent explicitly".

</para>
    </sect1>
  </chapter>
  <chapter xml:id="oneprojectatatime">
    <title>Make revolution, one project at a time</title>
    <sect1>
      <title>Not everyone uses stirmake yet</title>
<para>

For build systems, the most important thing to note is that when a new build
system intended to displace make appears, not everyone uses the new build
system at the time the new build system appears. Transition is slow, and since
projects may include subprojects with potentially different build systems, a
new build system can be successful in displacing make only when it is as
compatible with make as possible. Importantly, GNU make should be able to
invoke subprojects that use stirmake, with full jobserver guest, and the
top-level project built with stirmake should be possible to execute numerous
GNU make subprojects with full jobserver host.

</para><para>

Stirmake has both jobserver guest and host. When used as host, it actually uses
a socket pair, not a pipe, but the socket pair has been tested with GNU make
and found to work. The reason socket pair is superior is that pipes do not
support the flag MSG_DONTWAIT, but socket pairs do. The pipe cannot be marked
nonblocking by stirmake, since GNU make expects it to be blocking, but stirmake
requires nonblocking read. So what stirmake does is that it uses poll() to
check if there's something to read, and only if there's something to read, it
tries recv with MSG_DONTWAIT, and if it was found to not be a socket, it arms
an interval timer to 10 milliseconds, and executes read. The interval timer
only causes a penalty of 10 milliseconds in case something else stole the
character from the pipe that was there previously when used with poll().

</para>
    </sect1>
    <sect1>
      <title>Interfacing to command-line tools that specify flags etc</title>
<para>

Sometimes, there is a configuration utility that tells the arguments that
should be used for compiling something. An example: python3-config --includes
and python3-config --libs. These commands give arguments to C compiler (where
#included files are) and linker (what to link in addition to Python). Stirmake
supports interfacing to such tools with backtick-equals and
backtick-backtick-equals operators.

</para><para>

The backtick-backtick-equals operator creates a string list, separated with
spaces. It is what python3-config --includes and python3-config --libs need to
use, since they give several arguments in one line. Also, the
backtick-backtick-equals removes the trailing newline present in just about
every command you can execute with shell:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$PYTHON3_INCLUDES ``= ["python3-config", "--includes"]
$PYTHON3_LIBS ``= ["python3-config", "--libs"]
@call @dump($PYTHON3_INCLUDES)
@call @dump($PYTHON3_LIBS)
</programlisting>

...which prints:
<programlisting>
["-I/usr/include/python3.8", "-I/usr/include/python3.8"]
["-lcrypt", "-lpthread", "-ldl", "-lutil", "-lm", "-lm"]
</programlisting>

The single backtick variant gives you the raw output of the command:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$PYTHON3_RAW_INCLUDES `= ["python3-config", "--includes"]
$PYTHON3_RAW_INCLUDES_CHOMPED = @chomp($PYTHON3_RAW_INCLUDES)
@call @dump($PYTHON3_RAW_INCLUDES)
@call @dump($PYTHON3_RAW_INCLUDES_CHOMPED)
</programlisting>

...which prints:
<programlisting>
"-I/usr/include/python3.8 -I/usr/include/python3.8\n"
"-I/usr/include/python3.8 -I/usr/include/python3.8"
</programlisting>

Here the @chomp builtin is necessary, since the raw command output includes a
trailing newline, which is removed by @chomp if present.

</para>
    </sect1>
    <sect1>
      <title>Interfacing to environment</title>
<para>

One possible way to interface to environment is to invoke the shell to
parse environment variables. However, it is a rather heavyweight thing to do
for a lightweight operation. Still, it works:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$CC_RAW `= ["sh", "-c", "echo $CC"]
$CC_CHOMPED = @chomp($CC_RAW)
@if($CC_CHOMPED[@] == 0)
  $CC_CHOMPED = "cc"
@endif
@call @dump($CC_CHOMPED)
</programlisting>

Note that this $CC_CHOMPED can only include the compiler, not any arguments
to it. If you want to support space-separated arguments in CC, you need to
use the two backtick variant, and the list length getting is different from
the string length getting, because string length operator uses @ which list
length operator does not have:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$CC_PLUS_ARGS ``= ["sh", "-c", "echo $CC"]
@if($CC_PLUS_ARGS[] == 0)
  $CC_PLUS_ARGS = ["cc"]
@endif
@call @dump($CC_PLUS_ARGS)
</programlisting>

</para><para>

However, a better approach is to use @getenv since it does not need invoking
the shell:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$CC = @getenv("CC")
@if(@type($CC) == @type(@nil) || $CC[@] == 0)
  $CC = "cc"
@endif
@call @dump($CC)
</programlisting>

Now this works if CC can only contain compiler name. If it needs to support
containing arguments to compiler too, then @strwordlist is needed, which
conveniently treats @nil as an empty string:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$CC = @strwordlist(@getenv("CC"), " \t")
@if($CC[] == 0)
  $CC = ["cc"]
@endif
@call @dump($CC)
</programlisting>
Note how @strwordlist takes the separators, which in this case are space and
tab. Multiple separators mean different separator characters, not a string
separator that needs to contain the characters in the given order.

</para>
    </sect1>
    <sect1>
      <title>Why compiler name should be a list with arguments</title>
<para>

The previous section showed two ways of parsing CC from environment:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$CC = @getenv("CC")
@if(@type($CC) == @type(@nil) || $CC[@] == 0)
  $CC = "cc"
@endif
@call @dump($CC)
</programlisting>
...which gets a single string, and:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$CC = @strwordlist(@getenv("CC"), " \t")
@if($CC[] == 0)
  $CC = ["cc"]
@endif
@call @dump($CC)
</programlisting>
...which gets a list containing compiler and its arguments.

</para><para>

The question is: which should you use? In most cases, even though CC may often
contain just one binary name, in some cases there may be environments that
somewhat incorrectly use arguments too in CC, instead of (or in addition to)
having the arguments in CFLAGS. In such a case, you need to use the
@strwordlist variant that splits CC into an executable binary name and
potential arguments to it. It affects the use, as the first variant without
support of optional arguments is used as:
<programlisting>
$(CCCMD)&lt;&gt; = [$(CC), @$(CFLAGS), "-c", "-o", $@, $&lt;]
</programlisting>
...whereas the second variant with support of optional arguments is used as:
<programlisting>
$(CCCMD)&lt;&gt; = [@$(CC), @$(CFLAGS), "-c", "-o", $@, $&lt;]
</programlisting>
...since in the second case, the entire CC list needs to be embedded in the
command line.

</para><para>

Why the somewhat incorrect inclusion of arguments to CC is prevalent is that
make treats everything as a space-separated list. So with make, CC that
contains spaces means command name and optional arguments to it. For full
compatibility with make, it is recommended that you follow the same approach
in stirmake.

</para>

    </sect1>
    <sect1>
      <title>Integration to subproject cleaning systems with clean hooks</title>
      <!-- integration to subproject cleaning systems with clean hooks -->
<para>

Stirmake has automatic cleaning, but GNU make does not. If a stirmake project
has GNU make based subprojects as git submodules, there needs to be ways to
call the explicitly specified cleaning rules of the subprojects.

</para><para>

This is made possible by clean hooks. There are three of them: @cleanhook,
@distcleanhook and @bothcleanhook for smka -c, smka -b and smka -bc,
respectively. If the subproject does not support some of these hooks (an
example: if there is "make clean" for cleaning object files and "make
distclean" for cleaning everything, but no way to clean just binaries), the
hook can be specified with "false" as the command, causing an error.

</para><para>

An example of calling clean hooks with make:
<programlisting>
@toplevel
@strict

@cleanhook:
@	["make", "-C", "subproj", "clean"]

@distcleanhook:
@	["false"]

@bothcleanhook:
@	["make", "-C", "subproj", "distclean"]

@phonyrule: 'all':
@	["echo", "all"]
</programlisting>

</para>
    </sect1>
    <sect1>
      <title>Recursive directory dependencies</title>
<para>

Stirmake has the possibility to depend on the latest modification time of the
directory hierarchy. An example: if you have a submodule "argon2" that builds
"argon2/libargon.a", you can interface to it as follows:

<programlisting>
@toplevel
@strict

@rectgtrule: 'argon2/libargon2.a': @recdep 'argon2'
@       ["make", "-C", "argon2"]

@cleanhook:
@       ["make", "-C", "argon2", "clean"]

@bothcleanhook:
@       ["make", "-C", "argon2", "clean"]
</programlisting>

Here the important keywords are @rectgtrule and @recdep. @recdep means that
the rule depends on the latest modification time in the recursive directory
hierarchy. An alternative to @rectgtrule is @detouchrule.

</para><para>

@detouchrule rolls back the timestamp of the sources so that if "make -C argon"
would build one or more targets, the modification time of them would be newer
than the modification time of some of the sources, meaning one of the targets
would be considered "older" than the source. After @detouchrule, the recursive
sources have timestamps rolled back, so none of them is considered "older" than
some files in the recursive dependency hierarchy.

</para><para>

@rectgtrule rolls forward the timestamps of the targets to the same value, so
one of the targets is not older than the other target and the sources. The
timestamp is never rolled backwards, only forwards if there is any change.

</para><para>

Either @rectgtrule of @detouchrule should be specified if there is @recdep. It
it up to the user to decide which is the better strategy, changing the
timestamps of the recursive sources, or hanging the timestamps of the targets.
Without either, if the sub-make builds two or more targets, it is guaranteed
that one of the targets is newer than the other, which causes an unnecessary
rebuild which doesn't happen with @rectgtrule or @detouchrule if the target
list is fully specified.

</para><para>

If neither @rectgtrule nor @detouchrule is used for a rule that is built using
a sub-make, at least @mayberule should be specified. @mayberule means the rule
may or may not update its target. With make, this is always the case, since
make intelligently deduces based on timestamps whether the target is
up-to-date. If stirmake as the parent process decudes target is not up-to-date,
but make as the child process deduces target is up-to-date, stirmake executes a
command that does not modify the timestamp of the target in this special case.
In this case, stirmake would fail. Specifying @mayberule (and colon) before the
target allows it to work:
<programlisting>
@toplevel
@strict

@mayberule: 'argon2/libargon2.a': @recdep 'argon2'
@       ["make", "-C", "argon2"]

@cleanhook:
@       ["make", "-C", "argon2", "clean"]

@bothcleanhook:
@       ["make", "-C", "argon2", "clean"]
</programlisting>


</para>
    </sect1>
  </chapter>
  <chapter xml:id="scopingandsubdirectories">
    <title>Scoping and subdirectories</title>
    <sect1 xml:id="lexdyn">
      <title>Lexical and dynamic scoping</title>
<para>

Some programming languages are lexically scoped. Others are dynamically scoped.
The programming language of stirmake, Amyplan, supports both scoping types.

An example of lexical scoping can be made as follows. Let us assume there are
two nested directories, scoping and scoping/subdir. Both of them contain a
Stirfile, scoping/Stirfile:
<programlisting>
@toplevel
@strict

@phonyrule: 'all':

$VAR = 1

@function $FN()
  @dump("---")
  @dump(@L$VAR)
  @dump(@D$VAR)
@endfunction

@call $FN()
@dirinclude "subdir"
</programlisting>
...and scoping/subdir/Stirfile:
<programlisting>
@subfile
@strict

@phonyrule: 'all':

$VAR = 2

@call $FN()
</programlisting>

In this case, the Stirfile system execution with smka prints:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/scoping
"---"
1
1
"---"
1
2
stirmake: Nothing to be done.
</programlisting>

So lexical scoping accesses the variable where the function was defined.
Dynamic scoping accesses the variable where the function was called.

</para><para>

Six other scoping specifiers are:
<itemizedlist mark="bullet">
<listitem><para>@LP: lexical parent scope</para></listitem>
<listitem><para>@LO: lexical scope without recursion to parent</para></listitem>
<listitem><para>@LPO: lexical parent scope without recursion to grandparent</para></listitem>
<listitem><para>@DP: dynamic parent scope</para></listitem>
<listitem><para>@DO: dynamic scope without recursion to parent</para></listitem>
<listitem><para>@DPO: dynamic parent scope without recursion to grandparent</para></listitem>
</itemizedlist>

It is also possible to use immediate evaluation:
<itemizedlist mark="bullet">
<listitem><para>@I: immediate scope</para></listitem>
<listitem><para>@IO: immediate scope without recursion to parent</para></listitem>
<listitem><para>@IP: immediate parent scope</para></listitem>
<listitem><para>@IPO: immediate parent scope without recursion to grandparent</para></listitem>
</itemizedlist>

Immediate evaluation accesses the variable immediately, with no future
changes applied. Example:
<programlisting>
@toplevel
@strict

@phonyrule: 'all':

$VAR = 1

@function $FN()
  @dump(@L$VAR)
  @dump(@I$VAR)
@endfunction

$VAR = 2

@call $FN()
</programlisting>

This prints:
<programlisting>
2
1
stirmake: Nothing to be done.
</programlisting>

Note how the immediate access captures the variable immediately at parsing
time, with no future changes applied. In contrast, lexical access uses the
scope of function definition (lexical scoping), but latest variable within that
scope.

</para>
      <!-- lexical vs dynamic: we support both -->
    </sect1>
    <sect1 xml:id="creatingscopes">
      <title>Creating new scopes, and holey scopes</title>
<para>

It is possible to create scopes with @beginscope and @endscope. For example:

<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'thisscope' 'subscope'

$VAR = ["a"]

@beginscope
$VAR += ["b"]
@phonyrule: 'subscope':
@	["echo", @$VAR]
@endscope

@phonyrule: 'thisscope':
@	["echo", @$VAR]
</programlisting>

In this case, there are two rules, 'thisscope' and 'subscope' which are in
different scopes. Both rules print their idea of $VAR, which is different due
to scoping. This Stirfile prints:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/beginscope
[., subscope] echo a b
a b
[., thisscope] echo a
a
</programlisting>

</para><para>

Also, holey scopes were demonstrated already, but re-demonstrating them is
relevant in this section again. Holey scope is a scope where implicit recursion
to parent scope is not present, but you can always access the lexical parent
scope explicitly with @LP. This provides a convenient way of controlling what
is present in the sub-scope. Example from Stirfile of stirmake:

<programlisting>
@beginholeyscope
  $(CC) = @LP$(CC)
  $(CFLAGS) = @LP$(CFLAGS)
  $(WITH_LUA) = @LP$(WITH_LUA)
  $(LUAINCS) = @LP$(LUAINCS)
  $(LUALIBS) = @LP$(LUALIBS)
  $(FLEX) = @LP$(FLEX)
  $(BYACC) = @LP$(BYACC)
  @projdirinclude "abce"
@endscope
</programlisting>

In this case, the defined variables are visible inside the holey scope (and
inside the scope of the subproject "abce"), but others are not.

</para>
    </sect1>
    <sect1 xml:id="namedscopes">
      <title>Named scopes and accessing them</title>
<para>

Scopes can be named. With @beginscope or @beginholeyscope, it is possible
to add a name of the created scope:

<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'thisscope' 'subscope'

$VAR = ["a"]

@beginscope $SCOPE
$VAR += ["b"]
@phonyrule: 'subscope':
@	["echo", @$VAR]
@endscope

@phonyrule: 'thisscope':
@	["echo", @$VAR]
@	["echo", @@SC($SCOPE)$VAR]
</programlisting>

This prints:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/namedscope
[., subscope] echo a b
a b
[., thisscope] echo a
a
[., thisscope] echo a b
a b
</programlisting>

Note how in @@SC the first @ means "include the whole list into the array", and
the second @ is part of the specifier @SC of accessing named scopes. Also
instead of @SC you can use @SCO to prevent recursion to the parent of the named
scope.

</para><para>

With @dirinclude and @projdirinclude, you specify the scope with @scopename:

<programlisting>
@toplevel
@strict
@phonyrule: 'all': 'thisscope'

$VAR = ["a"]

@dirinclude @scopename $SCOPE "subdir"

@phonyrule: 'thisscope':
@	["echo", @$VAR]
@	["echo", @@SC($SCOPE)$VAR]
</programlisting>

...and the subdir/Stirfile:
<programlisting>
@subfile
@strict
@phonyrule: 'all':
$VAR += ["b"]
</programlisting>

...which prints:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/scopename
[., thisscope] echo a
a
[., thisscope] echo a b
a b
</programlisting>

</para><para>

Note that @dirinclude can be used to include several directories in one line
by having an array, but this does not work with @scopename. When @scopename is
specified, only one included directory per line is permitted.

</para>
    </sect1>
    <sect1 xml:id="dirupdirdown">
      <title>Specifying library lists that work everywhere</title>
<para>

All stirmake commands are executed in the directory where the rule was created.
It is possible to refer to files and directories inside parent directories with
.. entries. For example, if you have directory prog/prog1/ and library
lib/libcommon.a, inside the prog/prog1/ directory you would refer to this as:
'../../lib/libcommon.a'.

</para><para>

However, sometimes changes will be made to the directory structures. An example
is where prog/prog1/ is moved to prog1/ directly on the top-level directory. In
this case, the '../../lib/libcommon.a' would fail and need to be modified to
'../lib/libcommon.a'. Clearly, this kind of approach is not maintainable.

</para><para>

There are two special directory built-ins that are helpful in managing path
strings. They are @dirdown and @dirup.

</para><para>

For example, inside prog/prog1 you may instead of '../../lib/libcommon.a' use
@dirup . '/lib/libcommon.a'. In this case, @dirup gives the relative path to
the top-level directory. This way, it is possible for example in the top-level
Stirfile to add this variable function with delayed evaluation:

<programlisting>
$LIBCOMMON&lt;&gt; = @dirup . '/lib/libcommon.a'
</programlisting>

If this function is evaluated as $LIBCOMMON&lt;&gt; in any subdirectory, it
gives the correct path to libcommon.a.

</para><para>

Also it is possible in sub-Stirfile lib/Stirfile to add this:
<programlisting>
$DIRDOWN = @dirdown
$LIBCOMMON&lt;&gt; = @dirup . '/' . @L$DIRDOWN . '/libcommon.a'
</programlisting>

Note the usage of lexical scoping to evaluate $DIRDOWN, so that the @dirdown
from top-level diretory to lib directory is always used, not to the directory
where the caller is present.

</para><para>

Then in the top-level Stirfile you would have:
<programlisting>
@dirinclude @scopename $LIBSC "lib"
$LIBCOMMON = @SC($LIBSC) $LIBCOMMON
@dirinclude "prog"
</programlisting>

Then any Stirfile inside prog can use $LIBCOMMON&lt;&gt; which gives the
correct path to libcommon.a.

</para><para>

This way, library linking with relative paths is easy. Also it is possible to
use the same way to construct include directory arguments to C compiler (-I
argument).

</para>
    </sect1>
  </chapter>
  <chapter xml:id="examplelargeprojects">
    <title>Example large or complex projects</title>
    <sect1>
      <title>camftpd</title>
<para>

<link xlink:href="https://github.com/jmtilli/camftpd">camftpd</link> is an
insert-only FTP server supporting only a single directory. It doesn't support
deleting or getting files, or subdirectories. The project is very small, but
what makes it somewhat complex is that it interfaces to the GNU make based
build system of submodule argon2.

</para><para>

Here is the Stirfile of camftpd:

<programlisting>
@toplevel
@strict

$CC="cc"
$CFLAGS=["-Wall", "-O3"]
$LIBS=['-pthread']

@phonyrule: 'all': 'camftpd' 'camftpdpwenc'

@rectgtrule: 'argon2/libargon2.a': @recdep 'argon2'
@	["make", "-C", "argon2"]

@cleanhook:
@	["make", "-C", "argon2", "clean"]

@bothcleanhook:
@	["make", "-C", "argon2", "clean"]

'camftpd': 'camftpd.o' 'argon2/libargon2.a'
@	[$CC, @$CFLAGS, "-o", $@, @@suffilter($^, ".o"), @@suffilter($^, ".a"), @$LIBS]

'camftpd.o': 'camftpd.c'
@	[$CC, @$CFLAGS, "-c", "-o", $@, $&lt;]

'camftpdpwenc': 'camftpdpwenc.o' 'argon2/libargon2.a'
@	[$CC, @$CFLAGS, "-o", $@, @@suffilter($^, ".o"), @@suffilter($^, ".a"), @$LIBS]

'camftpdpwenc.o': 'camftpdpwenc.c'
@	[$CC, @$CFLAGS, "-c", "-o", $@, $&lt;]
</programlisting>

Note the @rectgtrule (an alternative would be @detouchrule) and @recdep. These
make Stirmake intelligently attempt to determine whether the sub-make needs to
be invoked at all. If it is invoked where it doesn't need to be invoked, the
damage is not massive, as the only printed additional lines in this case would
be:

<programlisting>
stirmake: Using directory /home/YOURUSERNAME/camftpd
[., argon2/libargon2.a] make -C argon2
make: Entering directory '/home/YOURUSERNAME/camftpd/argon2'
Building with optimizations for native
make: Nothing to be done for 'all'.
make: Leaving directory '/home/YOURUSERNAME/camftpd/argon2'
[., camftpdpwenc] cc -Wall -O3 -o camftpdpwenc camftpdpwenc.o argon2/libargon2.a -pthread
[., camftpd] cc -Wall -O3 -o camftpd camftpd.o argon2/libargon2.a -pthread
</programlisting>

In this case, @detouchrule would be somewhat better, as unnecessary invocation
would print only:
<programlisting>
stirmake: Using directory /home/YOURUSERNAME/camftpd
[., argon2/libargon2.a] make -C argon2
make: Entering directory '/home/YOURUSERNAME/camftpd/argon2'
Building with optimizations for native
make: Nothing to be done for 'all'.
make: Leaving directory '/home/YOURUSERNAME/camftpd/argon2'
</programlisting>
...without rebuild of camftpd and camftpdpwenc.

</para>
    </sect1>
    <sect1>
      <title>fastdiv</title>
<para>

<link xlink:href="https://github.com/jmtilli/fastdiv">fastdiv</link> is a very
simple project that demonstrates how "fast division by invariant integers with
multiplication" algorithm can be implemented in C code. Probably all important
C compilers today support it for invariant integers, but integers that are
rarely changing or invariant but not compile-time invariant are use cases where
fastdiv is needed if the performance of the faster division is useful.

</para><para>

The project is very simple, but the complexity of the Stirfile is in the
$MODULE(...) function that offers a convenient way of adding all rules in a
module, with very few lines, eliminating boilerplate code. The $MODULE(...)
function requires a simple helper $LIST_TO_DICTS_SIMPLE(...).

</para><para>

The top-level Stirfile is:
<programlisting>
@toplevel
@strict

@fileinclude @ignore "opts.smk"

# You can modify these for compilation
$CC ?= "cc"
$CFLAGS ?= ["-g", "-O2", "-Wall", "-Wextra", "-Wsign-conversion", "-Wno-missing-field-initializers", "-Wno-unused-parameter", "-Wshadow", "-Wstrict-prototypes", "-Wmissing-prototypes", "-Wpointer-arith", "-Werror", "-std=gnu11", "-fPIC"]
$LDFLAGS ?= []

# You can modify these during development
$MODS = ["lib", "examples"]

# You probably don't want to modify anything below this line

@function $LIST_TO_DICTS_SIMPLE($list, $param)
  @locvar $i=0
  @locvar $dicts=[]
  @for($i=0,$i&lt;$list[],$i=$i+1)
    @append($dicts, {$param: $list[$i]})
  @endfor
  @return $dicts
@endfunction

@function $MODULE($lib, $src_lib, $src_prog, $libs, $unitdeps, $unitcmds)
  @locvar $src = [@$src_lib, @$src_prog]
  @locvar $obj_lib = @sufsuball($src_lib, ".c", ".o")
  @locvar $obj_prog = @sufsuball($src_prog, ".c", ".o")
  @locvar $obj = @sufsuball($src, ".c", ".o")
  @locvar $dep = @sufsuball($src, ".c", ".d")
  @locvar $prog = @sufsuball($src_prog, ".c", "")
  @locvar $alldeps = [@$prog, $lib]
  @locvar $i = 0
  @addrule({"tgts": [{"name": "all"}], "attrs": {"phony": @true}, \
            "deps": @L$LIST_TO_DICTS_SIMPLE($alldeps, "name")})
  @addrule({"tgts": [{"name": "unit"}], "attrs": {"phony": @true}, \
            "deps": @L$LIST_TO_DICTS_SIMPLE($unitdeps, "name"), \
            "shells": [{"embed": @true, "cmds": $unitcmds}]})
  @for($i=0,$i&lt;$obj[],$i=$i+1)
    @addrule({"tgts": [{"name": $obj[$i]}], \
              "deps": [{"name": $src[$i]}, {"name": $dep[$i]}], \
              "shells": [{"cmd": [ \
                          @D$(CC), @@D$(CFLAGS), "-c", "-o", $obj[$i], \
                          $src[$i]]}]})
    @addrule({"tgts": [{"name": $dep[$i]}], \
              "deps": [{"name": $src[$i]}], \
              "shells": [{"cmd": [ \
                          @D$(CC), @@D$(CFLAGS), "-M", "-o", $dep[$i], \
                          $src[$i]]}]})
  @endfor
  @for($i=0,$i&lt;$prog[],$i=$i+1)
    @addrule({"tgts": [{"name": $prog[$i]}], \
              "deps": [{"name": $obj_prog[$i]}, \
                       {"name": $lib}, \
                       @@L$LIST_TO_DICTS_SIMPLE($libs, "name")], \
              "shells": [{"cmd": [ \
                          @D$(CC), @@D$(CFLAGS), "-o", $prog[$i], \
                          $obj_prog[$i], $lib, @$libs, @@D$(LDFLAGS), \
                          "-lpthread", "-ldl"]}]})
  @endfor
  @addrule({"tgts": [{"name": $lib}], \
            "deps": @L$LIST_TO_DICTS_SIMPLE($obj_lib, "name"), \
            "shells": [{"embed": @true, "cmds": [ \
                        ["rm", "-f", $lib], \
                        ["ar", "rvs", $lib, @$obj_lib]]}]})
@endfunction

$MODS_ALL = @sufsuball($MODS, "", "/all")
$MODS_UNIT = @sufsuball($MODS, "", "/unit")

@phonyrule: 'all': $MODS_ALL 'fastdiv'

@phonyrule: 'unit': $MODS_UNIT 'unit_root'

'fastdiv': 'fastdiv.c'
@	[@D$(CC), @@D$(CFLAGS), "-o", @D$@, @D$&lt; @@D$(LDFLAGS)]

@phonyrule: 'unit_root':
@	["./fastdiv"]

@dirinclude $MODS
</programlisting>

...and "lib/Stirfile" is:

<programlisting>
@subfile
@strict

# You can modify these
$SRC_LIB = ["fastdivlib.c"]
$SRC_PROG = []
$LIB = "libfastdiv.a"
$EXTRACFLAGS = []
$CFLAGS = [@$CFLAGS, @$EXTRACFLAGS]
$LIBS = []
$UNITDEPS = []
$UNITCMDS = []

# You won't want to modify anything below this line
@call $MODULE($LIB, $SRC_LIB, $SRC_PROG, $LIBS, $UNITDEPS, $UNITCMDS)

@cdepincludes @autophony @autotarget @ignore \
  @sufsuball([@$SRC_PROG, @$SRC_LIB], ".c", ".d")
</programlisting>

...and examples/Stirfile is:

<programlisting>
@subfile
@strict

# You can modify these
$SRC_LIB = []
$SRC_PROG = ["main.c"]
$LIB = "libexamples.a"
$EXTRACFLAGS = ["-I../lib"]
$CFLAGS = [@$CFLAGS, @$EXTRACFLAGS]
$LIBS = ["../lib/libfastdiv.a"]
$UNITDEPS = []
$UNITCMDS = [["./main"]]

# You won't want to modify anything below this line
@call $MODULE($LIB, $SRC_LIB, $SRC_PROG, $LIBS, $UNITDEPS, $UNITCMDS)

@cdepincludes @autophony @autotarget @ignore \
  @sufsuball([@$SRC_PROG, @$SRC_LIB], ".c", ".d")
</programlisting>

Note how the $MODULE function eliminated a lot of boilerplate rules.

</para>
    </sect1>
    <sect1>
      <title>pptk</title>
    </sect1>
    <sect1>
      <title>nmsynproxy</title>
    </sect1>
    <sect1>
      <title>ldpairwall</title>
    </sect1>
    <sect1>
      <title>cghcpcli</title>
    </sect1>
    <sect1>
      <title>yale</title>
    </sect1>
    <sect1>
      <title>stirmake</title>
    </sect1>
    <sect1>
      <title>caj</title>
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_advancedprogramming">
  <title>Advanced stirmake programming</title>
  <chapter xml:id="programmingwithamyplan">
    <title>Programming Stirmake with Amyplan</title>
    <!-- abce and amyplan -->
    <!-- installing amyplan in abce -->
    <!-- creating amyplan scripts -->
    <!-- lack of REPL due to being yacc-based -->
    <!-- constant strings and modifiable packet buffers, @str2pb, @pb2str -->
    <!-- pbnew -->
    <!-- packet buffer access with be8, le8, be16, be32, le16, le32 -->
    <!-- TODO: memcpy with packet buffers, needs abce support -->
    <!-- io streams and interacting with them -->
    <!-- math, fpclassify -->
    <!-- JSON -->
  </chapter>
  <chapter xml:id="advancedtricks">
    <title>Advanced tricks</title>
    <!-- pattern rules, TODO perhaps earlier? -->
    <!-- scopes stored in variables -->
    <!-- deponly for additional dependencies -->
    <!-- @order and @wait -->
    <!-- dynamically adding rules -->
    <!-- dynamically adding dependencies -->
    <!-- version conditionals and minimum version requirements, future b-ins -->
    <!-- finding gitmake version and version history -->
    <!-- hacking abce: need for all to be visible to abce at all times -->
  </chapter>
  </part>
</book>
