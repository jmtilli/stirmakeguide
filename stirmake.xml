<?xml version="1.0" encoding="UTF-8"?>
<!-- vim: set noai indentexpr&
-->
<book xml:id="stirmake" xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Scalable true implementation of recursive make (stirmake)</title>
    <author>
      <personname>
        <firstname>Juha-Matti</firstname>
        <surname>Tilli</surname>
      </personname>
    </author>
    <copyright>
      <year>2023-2025</year>
      <holder>Juha-Matti Tilli</holder>
    </copyright>
  </info>
  <part xml:id="part_make">
  <title>Make, a historical tool</title>
  <chapter xml:id="make">
    <title>Make, the de facto build tool</title>

<sect1 xml:id="basics">
<title>Introduction to basics of make</title>

The first and most well-known build tool is make. Stuart Feldman authored make
in 1976 in Bell Labs. The idea of make is that while build can be done using a
shell script, a shell script executes all build commands uncondionally. In a
small project consisting of a single C language source file, this is not a
problem. However, larger projects can consist of multiple C source files, for
example Linux 6.17-rc7 contains 35778 source files, not counting header files.
If in a large project a small change is made, it should affect only on the code
that is dependent on it. For example, if a C source file is changed, only that
source file should be recompiled and any .a archive, shared library or
executable binary dependent on it should be re-linked.

A simple Makefile could be as follows:
<programlisting>
.PHONY: all
all: myprog
CC=cc
CFLAGS=-O1
myprog: myprog.c
	$(CC) $(CFLAGS) -o $@ $^
</programlisting>

Here $@ refers to the target name, wheras $^ contains all dependencies. Instead of $^, the first dependency can be referred to with $&lt;.

In this case, myprog is re-built only if nonexistent, or if its timestamp is
before the modification timestamp of myprog.c.

</sect1>
<sect1 xml:id="cleanandmakefiledep">
<title>Cleaning and dependency on Makefile</title>

A problem immediately appears. The file myprog does not depend on Makefile.
So if CFLAGS is modified, myprog won't be rebuilt. The answer to this generally
is two-fold.

Firstly, a target clean is added to clean everything:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
myprog: myprog.c
	$(CC) $(CFLAGS) -o $@ $^
</programlisting>

Then if CFLAGS is modified, the user can run "make clean" and then "make". This
demonstrates that the all-important "make clean" must be executed very often
with make-based build systems. This also demonstrates that it's all too easy to
forget something from "make clean". For example, in this simple Makefile, if a
new target secondprog is added, it needs to be added to its rule, but also to
"make clean" rule which is often forgotten.

Another possibility is adding dependency to Makefile, but this requires some
changes so that it's not given to CC as an argument:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
myprog: myprog.c Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.c,$^)
</programlisting>

Note that filter is a GNU make extension, and may not be available in other
implementations of make.

However, with both approaches, the "solution" is to clean or re-build
everything if the Makefile is changed. This is a problem in cases where the
Makefile is huge, but only one command to build one target is modified. Both
"solutions" in this case recompile everything, not just the target that had
a change in its command.

</sect1>
<sect1 xml:id="largerprojects">
<title>Somewhat larger single-directory projects</title>
In larger projects, it is generally preferred to not compile binary from C
sources directly, but instead create object files that are then linked:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
	rm -f myprog.o mylib.o
myprog: myprog.o mylib.o Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
myprog.o: myprog.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
mylib.o: mylib.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
</programlisting>

Now there are two unclean approaches in this Makefile. First is that the
information about what object files are there is repeated to three locations:
the rule of the object file, the linking rule, and the "make clean" phony rule.
The second is that if there are N object files, the command to build them is
repeated N times. These can be solved with some GNU make extensions:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
</programlisting>

Now the list of object files is specified only once, and the rule to build an
object from a source is common to all object files. Note that already at this
stage, the standard POSIX make is not enough, an GNU extensions have to be
used.

</sect1>
<sect1 xml:id="headerfile">
<title>Header file dependencies</title>

However, this more complex Makefile suffers from the fact that compiling
myprog.c into myprog.o most likely requires inclusion of a header file,
mylib.h. So myprog.o depends on mylib.h. This can be specified as an additional
dependency in the Makefile:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
myprog.o: mylib.h
</programlisting>

But however, this approach does not scale. Every time a C file is modified and
a new header file is added, it must be documented in the Makefile. Worse, a
header file can include other headers, and all of them should be documented
in the Makefile. Clearly, something better is needed.

Fortunately, most C compilers support outputting dependencies, which can be
imported:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS) $(DEPS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -o $@ $&lt;
-include $(DEPS)
</programlisting>

So the C compiler then creates the files myprog.d mylib.d that both myprog.o
and mylib.o depend on mylib.h. This is fully automatic. Before a build has been
made, the .d dependency files don't exist, but then everything must be
initially compiled anyway. In this case, -MM means omit system header files.
With -M only, system header file dependencies would be stored in the .d files.

Also notice that instead of include, you use -include. This is because the
dependency files don't exist the first time make is run.

Is the Makefile now good enough? No, because if mylib.h is renamed to
mylibpublic.h, then the .d files contain reference to the old mylib.h and make
notices it can't find that file. So an empty phony rule is needed to affect
make in such a manner that it doesn't exit when finding a reference to a
nonexistent header file. Fortunately, the -M option has -MP which adds the
phony rules and now "make clean" is not necessary if a header is renamed:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS) $(DEPS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -o $@ $&lt;
-include $(DEPS)
</programlisting>

However, this is not all that needs to be done. The .d files aren't updated
if a header file changes, only the .o files are updated. Fortunately, most
C compilers have an option to solve this: -MT:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS) $(DEPS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
-include $(DEPS)
</programlisting>

Now the .d files finally work just fine. However, there were a lot of
difficulties in the road to make the ultimate dependency file mechanism.
</sect1>

  </chapter>
  <chapter xml:id="makemultidirproject">
    <title>Where make fails, multi-directory projects</title>
    <sect1 xml:id="makedirsep">
      <title>Make with directory separators</title>
      Let's consider you have a directory prog with file prog.c, and a directory lib with files lib1.c and lib2.c, creating a static library file liblib.a. Then the Makefile needs to create liblib.a and link it into prog. How to do this in make?

      Make does not have support for multiple nested directories, but make does accept slash in file names. So let's create a top-level Makefile that compiles stuff in directories prog and lib.

<programlisting>
.PHONY: all clean
all: prog/prog lib/liblib.a
CC=cc
CFLAGS=-O1
OBJLIB=lib/lib1.o lib/lib2.o
OBJPROG=prog/prog.o
OBJALL=$(OBJLIB) $(OBJPROG)
DEPALL=$(patsubst %.o,%.d,$(OBJALL))
clean:
	rm -f prog/prog lib/liblib.a
	rm -f $(OBJALL) $(DEPALL)
prog/prog: prog/prog.o lib/liblib.a Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^) $(filter %.a,$^)
lib/liblib.a: $(OBJLIB) Makefile
	rm -f $@
	ar rvs $@ $(filter %.o,$^)
$(OBJALL): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPALL): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
-include $(DEPALL)
</programlisting>

Note tht in this program listing, the argument -o $@ to make is necessary.
Without it, the C compile is executed in the top-level directory, and the
output file would be stored into this top-level directory, not in the
subdirectory where the source file is.

This approach works but suffers from the drawback that in a project of 3000
subdirectories like in Linux kernel, the one and only top-level Makefile would
grow into a huge monster which makes its maintenance practically impossible.
    </sect1>
    <sect1 xml:id="makefileperdir">
      <title>Another approach: Makefile per directory</title>
      <sect2 xml:id="recursivemaketest">
        <title>Let's try recursive make</title>
      </sect2>
      <sect2 xml:id="nocommonnamespace">
        <title>Fixing no common namespace: include file</title>
      </sect2>
      <sect2 xml:id="dangersofseparating">
        <title>Drawbacks and dangers of separating build to multiple DAGs</title>
        <!-- top-level directory must have module-level dependencies -->
        <!-- parallel build hard: explain the jobserver hack -->
        <!-- "Recursive Make Considered Harmful" -->
        <!-- so let's try another approach, inclusive make -->
      </sect2>
    </sect1>
    <sect1 xml:id="inclusivemake">
      <title>Another approach: one Makefile, module.mk per directory</title>
      <!-- refer to makedirsep: commands are executed in subdirectory -->
      <!-- one common namespace -->
      <!-- dangers of one common namespace when including sub-projects: this is where even die-hard inclusive make proponents switch to recursion -->
    </sect1>
    <sect1 xml:id="parallelmake">
      <title>Parallel make, jobserver and lack of multiple targets</title>
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_stirmakeintro">
  <title>Stirmake, a modern tool</title>
  <chapter xml:id="stirmakeintro">
    <title>Introducing stirmake</title>
    <sect1 xml:id="stirmakeinstall">
      <title>Compiling and installing stirmake</title>
      <!-- flex, byacc, POSIX, some non-POSIX or deprecated fn requirements -->
    </sect1>
    <sect1 xml:id="helloworld">
      <title>Compiling hello world</title>
      <!-- document phony rules here -->
      <!-- strict mode, in non-strict mode 4/2 is not equal to 2 -->
    </sect1>
    <sect1 xml:id="modularhellolib">
      <title>Modular hello from library</title>
      <!-- demonstrate nested recursive scoping here -->
      <!-- invoking stirmake: smka, (smkp), smkt -->
    </sect1>
    <sect1 xml:id="multiprocessing">
      <title>Multiprocessor machines</title>
      <!-- -ja, -la, etc -->
      <!-- need to specify all targets if there are multiple -->
      <!-- make does not support specifying all targets -->
    </sect1>
    <sect1 xml:id="tracingdebugging">
      <title>Tracing and debugging</title>
      <!-- tracing -->
      <!-- debugging -->
    </sect1>
  </chapter>
  <chapter xml:id="variabledatatypefunction">
    <title>Variables, data types and functions</title>
    <sect1 xml:id="dump">
      <title>Dump: hello from stirmake</title>
One of the most common tools you need all the time is @dump. It prints its argument in a format that works for all of the data types.

As an example, run this Stirfile:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@call @dump("Hello world")
@call @dump(123)
@call @dump(456.78)
@call @dump(@nil)
@call @dump(["foo", 5])
@call @dump({"bar": {"baz": [567, 89]}})
</programlisting>

It should print:
<programlisting>
stirmake: Using directory /home/juhis/smdb/hello
"Hello world"
123
456.77999999999997272
null
["foo", 5]
{"bar": {"baz": [567, 89]}}
stirmake: Nothing to be done.
</programlisting>

Note that dump is a debugging tool. If you want to print strings without the
quotation marks, you need some other tool. But a clear benefit of dump is that
it works for all data types.

Also note the @call specifiers before @dump. Every time an Amyplan statement
is run, without its output being saved to a variable, at top level (outside of
Amyplan functions), @call is needed. Amyplan has a distinction between
expressions and statements, and @dump is a statement. An alternative could be
calling @dump inside a function, in which case @call is not used:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
@function $AMYPLANFUN()
  @dump("Hello world")
  @dump(123)
  @dump(456.78)
  @dump(@nil)
  @dump(["foo", 5])
  @dump({"bar": {"baz": [567, 89]}})
@endfunction
@call $AMYPLANFUN()
</programlisting>

Note that since @dump is a statement instead of an expression, this does not
work:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$DISCARD=@dump("Hello world")
$DISCARD=@dump(123)
$DISCARD=@dump(456.78)
$DISCARD=@dump(@nil)
$DISCARD=@dump(["foo", 5])
$DISCARD=@dump({"bar": {"baz": [567, 89]}})
@call @dump($DISCARD)
</programlisting>

    </sect1>
    <sect1 xml:id="variables">
      <title>Defining variables</title>

Variables can be defined outside of functions with the following syntax:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR ?= @nil
@call @dump($MYVAR)
$MYVAR = [2, "fof", {"bar": {"baz": [567, 89]}}]
$MYVAR += [12345, 54321]
$MYVAR ?= @nil
@call @dump($MYVAR)
</programlisting>

Note the several assignment operators here. ?= is conditional assigment,
assign only if the variable is nonexistent. = is the normal assigment
operator. For lists, += allows appending multiple elements to the list.

Generally, it is recommended that you define variables $CC and $CFLAGS if you
compile C code. Both of them ideally should be arrays, since some Makefiles in
fact assign some of the arguments to $CC into $CC and not into $CFLAGS. Also
defining variables for sources and targets as arrays is typical.

Inside functions, accessing and assigning into global variables requires
scope information, lexical or dynamic. An example of lexical scoping:
<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR ?= @nil
@function $MYFUN()
  @L$MYVAR = 5
@endfunction
@function $MYFUN2()
  @locvar $MYVAR=321
  @dump(@L$MYVAR)
  @dump($MYVAR)
@endfunction
@call $MYFUN()
@call $MYFUN2()
</programlisting>

Lexical scoping @L means that the function acceses the scope in which it was
defined. Dynamic scoping with @D would mean the function accesses the scope in
which it was called. Local variables are accessed without scope specifiers.  If
a variale access happens inside a function, it is a local variable as default.
Even function calls need scope specifiers:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR ?= @nil
@function $MYFUN()
  @L$MYVAR = 5
@endfunction
@function $MYFUN2()
  @locvar $MYVAR=321
  @L$MYFUN()
  @dump(@L$MYVAR)
  @dump($MYVAR)
@endfunction
@call $MYFUN2()
</programlisting>

Note that local variables need to be defined at the start of the function.
If you need a local variable set in the middle of the function, you need to
define it at the start, but you can assign @nil into it if you don't have
anything better to assign.
    </sect1>
    <sect1 xml:id="specvar">
      <title>Special variables</title>

There are five special variables: $@, $&lt;, $^, $+ and $|.

Out of these, $@, $lt; and $^ are the most often used. $@ is the name of the
first target. $&lt; is the name of the first source. $^ is the names of all
sources, with duplicates removed. $+ is the same as $^, but duplicate source
files are repeated in the exact same order, which may be useful sometimes for
linking static libraries that may have circular dependencies. $| is the names
of all order-only dependencies.

Out of these, $@ and$&lt; are strings and the others are arrays of strings.

    </sect1>
    <sect1 xml:id="datatypes">
      <title>Data types, finally we can have spaces in filenames!</title>

As mentioned already, stirmake supports strings and arrays. This is a
difference with make since make supports only strings, and arrays are emulated
by space-delimited strings, which means a filename cannot contain spaces.

Stirmake, via its programming language Amyplan and bytecode engine abce
supports the following data types:

<itemizedlist mark="bullet">
<listitem><para>@nil</para></listitem>
<listitem><para>Boolean: @false or @true</para></listitem>
<listitem><para>Number: IEEE double precision floating point, can contain both integers and floating-point numbers, all 32-bit integers can be exactly specified</para></listitem>
<listitem><para>String: an immutable sequence of 8-bit characters, with Unicode as UTF-8 if used</para></listitem>
<listitem><para>Packet buffer: a mutable sequence of bytes, can be converted from/to strings, contents can be modified, length can be modified</para></listitem>
<listitem><para>Array: a mutable sequence of any objects of any types</para></listitem>
<listitem><para>Tree: a mapping from immutable strings to any objects of any type. Note that numbers cannot be used as keys, but numbers can be converted to strings which can be used as keys.</para></listitem>
<listitem><para>I/O streams: a reference to a file which can be use to read and write data</para></listitem>
<listitem><para>Functions, which contain reference to the lexical scope, and which may be called with the correct number of arguments</para></listitem>
<listitem><para>Several internal data types not exposed to the programmer</para></listitem>
</itemizedlist>

The @type expression can be used to obtain the type of a variable, but as it is
a number that doesn't document itself, you should use @type of an example object
against which the type of the object is compared:

<programlisting>
@toplevel
@strict
@phonyrule: 'all':
$MYVAR = @nil
@call @dump(@type($MYVAR) == @type(@nil))
@call @dump(@type($MYVAR) == @type(@false))
$MYVAR = 543.21
@call @dump(@type($MYVAR) == @type(123))
@call @dump(@type($MYVAR) == @type("foo"))
$MYVAR = @tostring($MYVAR)
@call @dump(@type($MYVAR) == @type("foo"))
$MYVAR = @tonumber($MYVAR)
@call @dump(@type($MYVAR) == @type(123))
$MYVAR = @tostring($MYVAR)
@call @dump(@type($MYVAR) == @type("foo"))
@call @dump(@type($MYVAR) == @type(@pbnew()))
$MYVAR = @str2pb($MYVAR)
@call @dump(@type($MYVAR) == @type("foo"))
@call @dump(@type($MYVAR) == @type(@pbnew()))
$MYVAR = @pb2str($MYVAR,0,$MYVAR{@})
@call @dump(@type($MYVAR) == @type("foo"))
@call @dump(@type($MYVAR) == @type(@pbnew()))
$MYVAR = [1,2,3]
@call @dump(@type($MYVAR) == @type([]))
@call @dump(@type($MYVAR) == @type({}))
</programlisting>

Note the @tostring and @tonumber operations which can be used to convert
between strings and numbers, and the @str2pb and @pb2str operations which can
be used to convert between strings and packet buffers. The @pb2str operation
requires starting index (0-based starts from 0) and length of slice to take
from the packet buffer. The @str2pb always takes the entire string, but <link
linkend="string">strings can be sliced with @strsub</link> if needed, and then
converted to a packet buffer with @str2pb of the sliced string.

<!-- string -->


    </sect1>
    <sect1 xml:id="conditionals">
      <title>Conditionals</title>
      <!-- normal conditionals -->
      <!-- stirmake version conditional -->
    </sect1>
    <sect1 xml:id="loops">
      <title>Loops</title>
      <!-- while, for, once, break, continue, break N, continue N -->
    </sect1>
    <sect1 xml:id="string">
      <title>String</title>
      <!-- common operations -->
      <!-- chomp -->
      <!-- strstr, strrep, strlistjoin, strappend, strstrip -->
      <!-- strsub, strgsub, strset, strword, strwordcnt, strwordlist -->
      <!-- strcmp, strreverse, strupper, strlower, strfromchr -->
      <!-- string append -->
      <!-- tostring, tonumber -->
    </sect1>
    <sect1 xml:id="array">
      <title>Array</title>
      <!-- common operations -->
      <!-- list splice -->
      <!-- append -->
      <!-- appendlist -->
      <!-- array append assignment top-level only -->
    </sect1>
    <sect1 xml:id="simpletypes">
      <title>Simple data types: number, boolean, nil</title>
      <!-- common operations -->
    </sect1>
    <sect1 xml:id="tree">
      <title>Tree</title>
      <!-- common operations -->
      <!-- fordict, fordictprev, dictprev, dictnext -->
    </sect1>
    <sect1 xml:id="functiondelayeval">
      <title>Functions and delayed evaluation</title>
    </sect1>
    <sect1 xml:id="functionglobalscope">
      <title>Functions, global variables and scoping</title>
      <!-- calling one function from another function -->
      <!-- difference between functions and built-ins -->
    </sect1>
  </chapter>
  <chapter xml:id="commands">
    <title>How Stirmake executes its commands</title>
    <!-- tab, at-tab, at-at-tab -->
    <!-- the dangers of shell expansion -->
    <!-- shell can still be manually invoked -->
    <!-- build command and file size database -->
    <!-- move madness -->
    <!-- ignore -->
    <!-- noecho -->
    <!-- ismake and automatic make detection -->
  </chapter>
  <chapter xml:id="cleaning">
    <title>Automated cleaning with stirmake</title>
    <!-- distrule and disttgt -->
  </chapter>
  <chapter xml:id="conditional">
    <title>Conditional compilation</title>
  </chapter>
  </part>
  <part xml:id="part_stirmakelargescale">
  <title>Stirmake in large-scale systems</title>
  <chapter xml:id="multiproject">
    <title>Stirmake for entire project structures</title>
    <!-- including sub-projects -->
    <!-- invoking stirmake: smka, smkp, smkt -->
    <!-- controlling what to export with holey scopes -->
  </chapter>
  <chapter xml:id="oneprojectatatime">
    <title>Make revolution, one project at a time</title>
    <!-- Not everyone uses stirmake yet -->
    <!-- integration to jobserver and make autodetection -->
    <!-- backtick-equals, backtick-backtick-equals -->
    <!-- chomp -->
    <!-- getenv -->
    <!-- strwordlist -->
    <!-- recommendation for CC and CFLAGS support, both list of lists -->
    <!-- integration to subproject cleaning systems with clean hooks -->
    <!-- recdep and detouchrule/rectgtrule/mayberule -->
    <!-- make in same directory with mayberule -->
  </chapter>
  <chapter xml:id="scopingandsubdirectories">
    <title>Scoping and subdirectories</title>
    <!-- lexical vs dynamic: we support both -->
    <!-- holey scopes -->
    <!-- named scopes -->
    <sect1 xml:id="dirupdirdown">
      <title>Specifying library lists that work everywhere</title>
      <!-- introduce problem of specifying static dependencies -->
      <!-- @dirdown @dirup -->
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_advancedprogramming">
  <title>Advanced stirmake programming</title>
  <chapter xml:id="programmingwithamyplan">
    <title>Programming Stirmake with Amyplan</title>
    <!-- abce and amyplan -->
    <!-- creating amyplan scripts -->
    <!-- lack of REPL due to being yacc-based -->
    <!-- constant strings and modifiable packet buffers, @str2pb, @pb2str -->
    <!-- pbnew -->
    <!-- packet buffer access with be8, le8, be16, be32, le16, le32 -->
    <!-- TODO: memcpy with packet buffers, needs abce support -->
    <!-- io streams and interacting with them -->
    <!-- math, fpclassify -->
    <!-- JSON -->
  </chapter>
  <chapter xml:id="advancedtricks">
    <title>Advanced tricks</title>
    <!-- pattern rules, TODO perhaps earlier? -->
    <!-- scopes stored in variables -->
    <!-- deponly for additional dependencies -->
    <!-- @order and @wait -->
    <!-- dynamically adding rules -->
    <!-- dynamically adding dependencies -->
    <!-- version conditionals and minimum version requirements, future b-ins -->
    <!-- finding gitmake version and version history -->
    <!-- hacking abce: need for all to be visible to abce at all times -->
  </chapter>
  </part>
</book>
