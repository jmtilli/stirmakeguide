<?xml version="1.0" encoding="UTF-8"?>
<!-- vim: set noai indentexpr&
-->
<book xml:id="stirmake" xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Scalable true implementation of recursive make (stirmake)</title>
    <author>
      <personname>
        <firstname>Juha-Matti</firstname>
        <surname>Tilli</surname>
      </personname>
    </author>
    <copyright>
      <year>2023-2025</year>
      <holder>Juha-Matti Tilli</holder>
    </copyright>
  </info>
  <part xml:id="part_make">
  <title>Make, a historical tool</title>
  <chapter xml:id="make">
    <title>Make, the de facto build tool</title>

<sect1 xml:id="basics">
<title>Introduction to basics of make</title>

The first and most well-known build tool is make. Stuart Feldman authored make
in 1976 in Bell Labs. The idea of make is that while build can be done using a
shell script, a shell script executes all build commands uncondionally. In a
small project consisting of a single C language source file, this is not a
problem. However, larger projects can consist of multiple C source files, for
example Linux 6.17-rc7 contains 35778 source files, not counting header files.
If in a large project a small change is made, it should affect only on the code
that is dependent on it. For example, if a C source file is changed, only that
source file should be recompiled and any .a archive, shared library or
executable binary dependent on it should be re-linked.

A simple Makefile could be as follows:
<programlisting>
.PHONY: all
all: myprog
CC=cc
CFLAGS=-O1
myprog: myprog.c
	$(CC) $(CFLAGS) -o $@ $^
</programlisting>

Here $@ refers to the target name, wheras $^ contains all dependencies. Instead of $^, the first dependency can be referred to with $&lt;.

In this case, myprog is re-built only if nonexistent, or if its timestamp is
before the modification timestamp of myprog.c.

</sect1>
<sect1 xml:id="cleanandmakefiledep">
<title>Cleaning and dependency on Makefile</title>

A problem immediately appears. The file myprog does not depend on Makefile.
So if CFLAGS is modified, myprog won't be rebuilt. The answer to this generally
is two-fold.

Firstly, a target clean is added to clean everything:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
myprog: myprog.c
	$(CC) $(CFLAGS) -o $@ $^
</programlisting>

Then if CFLAGS is modified, the user can run "make clean" and then "make". This
demonstrates that the all-important "make clean" must be executed very often
with make-based build systems. This also demonstrates that it's all too easy to
forget something from "make clean". For example, in this simple Makefile, if a
new target secondprog is added, it needs to be added to its rule, but also to
"make clean" rule which is often forgotten.

Another possibility is adding dependency to Makefile, but this requires some
changes so that it's not given to CC as an argument:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
myprog: myprog.c Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.c,$^)
</programlisting>

Note that filter is a GNU make extension, and may not be available in other
implementations of make.

However, with both approaches, the "solution" is to clean or re-build
everything if the Makefile is changed. This is a problem in cases where the
Makefile is huge, but only one command to build one target is modified. Both
"solutions" in this case recompile everything, not just the target that had
a change in its command.

</sect1>
<sect1 xml:id="largerprojects">
<title>Somewhat larger single-directory projects</title>
In larger projects, it is generally preferred to not compile binary from C
sources directly, but instead create object files that are then linked:
<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
clean:
	rm -f myprog
	rm -f myprog.o mylib.o
myprog: myprog.o mylib.o Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
myprog.o: myprog.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
mylib.o: mylib.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
</programlisting>

Now there are two unclean approaches in this Makefile. First is that the
information about what object files are there is repeated to three locations:
the rule of the object file, the linking rule, and the "make clean" phony rule.
The second is that if there are N object files, the command to build them is
repeated N times. These can be solved with some GNU make extensions:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
</programlisting>

Now the list of object files is specified only once, and the rule to build an
object from a source is common to all object files. Note that already at this
stage, the standard POSIX make is not enough, an GNU extensions have to be
used.

</sect1>
<sect1 xml:id="headerfile">
<title>Header file dependencies</title>

However, this more complex Makefile suffers from the fact that compiling
myprog.c into myprog.o most likely requires inclusion of a header file,
mylib.h. So myprog.o depends on mylib.h. This can be specified as an additional
dependency in the Makefile:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
myprog.o: mylib.h
</programlisting>

But however, this approach does not scale. Every time a C file is modified and
a new header file is added, it must be documented in the Makefile. Worse, a
header file can include other headers, and all of them should be documented
in the Makefile. Clearly, something better is needed.

Fortunately, most C compilers support outputting dependencies, which can be
imported:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -o $@ $&lt;
-include $(DEPS)
</programlisting>

So the C compiler then creates the files myprog.d mylib.d that both myprog.o
and mylib.o depend on mylib.h. This is fully automatic. Before a build has been
made, the .d dependency files don't exist, but then everything must be
initially compiled anyway. In this case, -MM means omit system header files.
With -M only, system header file dependencies would be stored in the .d files.

Also notice that instead of include, you use -include. This is because the
dependency files don't exist the first time make is run.

Is the Makefile now good enough? No, because if mylib.h is renamed to
mylibpublic.h, then the .d files contain reference to the old mylib.h and make
notices it can't find that file. So an empty phony rule is needed to affect
make in such a manner that it doesn't exit when finding a reference to a
nonexistent header file. Fortunately, the -M option has -MP which adds the
phony rules and now "make clean" is not necessary if a header is renamed:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -o $@ $&lt;
-include $(DEPS)
</programlisting>

However, this is not all that needs to be done. The .d files aren't updated
if a header file changes, only the .o files are updated. Fortunately, most
C compilers have an option to solve this: -MT:

<programlisting>
.PHONY: all clean
all: myprog
CC=cc
CFLAGS=-O1
OBJS=myprog.o mylib.o
DEPS=$(patsubst %.o,%.d,$(OBJS))
clean:
	rm -f myprog
	rm -f $(OBJS)
myprog: $(OBJS) Makefile
	$(CC) $(CFLAGS) -o $@ $(filter %.o,$^)
$(OBJS): %.o: %.c %.d Makefile
	$(CC) $(CFLAGS) -c -o $@ $&lt;
$(DEPS): %.d: %.c Makefile
	$(CC) $(CFLAGS) -MM -MP -MT $*.d -MT $*.o -o $@ $&lt;
-include $(DEPS)
</programlisting>

Now the .d files finally work just fine. However, there were a lot of
difficulties in the road to make the ultimate dependency file mechanism.
</sect1>

  </chapter>
  <chapter xml:id="makemultidirproject">
    <title>Where make fails, multi-directory projects</title>
    <sect1 xml:id="makedirsep">
      <title>Make with directory separators</title>
      <!-- cc invoked in top-level directory, creates its outputs there -->
      <!-- option -o needed to tell to store output to subdirectory -->
    </sect1>
    <sect1 xml:id="makefileperdir">
      <title>Another approach: Makefile per directory</title>
      <sect2 xml:id="recursivemaketest">
        <title>Let's try recursive make</title>
      </sect2>
      <sect2 xml:id="nocommonnamespace">
        <title>Fixing no common namespace: include file</title>
      </sect2>
      <sect2 xml:id="dangersofseparating">
        <title>Drawbacks and dangers of separating build to multiple DAGs</title>
        <!-- top-level directory must have module-level dependencies -->
        <!-- parallel build hard: explain the jobserver hack -->
        <!-- "Recursive Make Considered Harmful" -->
        <!-- so let's try another approach, inclusive make -->
      </sect2>
    </sect1>
    <sect1 xml:id="inclusivemake">
      <title>Another approach: one Makefile, module.mk per directory</title>
      <!-- refer to makedirsep: commands are executed in subdirectory -->
      <!-- one common namespace -->
      <!-- dangers of one common namespace when including sub-projects: this is where even die-hard inclusive make proponents switch to recursion -->
    </sect1>
    <sect1 xml:id="parallelmake">
      <title>Parallel make, jobserver and lack of multiple targets</title>
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_stirmakeintro">
  <title>Stirmake, a modern tool</title>
  <chapter xml:id="stirmakeintro">
    <title>Introducing stirmake</title>
    <sect1 xml:id="stirmakeinstall">
      <title>Compiling and installing stirmake</title>
      <!-- flex, byacc, POSIX, some non-POSIX or deprecated fn requirements -->
    </sect1>
    <sect1 xml:id="helloworld">
      <title>Compiling hello world</title>
      <!-- document phony rules here -->
      <!-- strict mode, in non-strict mode 4/2 is not equal to 2 -->
    </sect1>
    <sect1 xml:id="modularhellolib">
      <title>Modular hello from library</title>
      <!-- demonstrate nested recursive scoping here -->
      <!-- invoking stirmake: smka, (smkp), smkt -->
    </sect1>
    <sect1 xml:id="multiprocessing">
      <title>Multiprocessor machines</title>
      <!-- -ja, -la, etc -->
      <!-- need to specify all targets if there are multiple -->
      <!-- make does not support specifying all targets -->
    </sect1>
    <sect1 xml:id="tracingdebugging">
      <title>Tracing and debugging</title>
      <!-- tracing -->
      <!-- debugging -->
    </sect1>
  </chapter>
  <chapter xml:id="variabledatatypefunction">
    <title>Variables, data types and functions</title>
    <sect1 xml:id="dump">
      <title>Dump: hello from stirmake</title>
    </sect1>
    <sect1 xml:id="variables">
      <title>Defining variables</title>
    </sect1>
    <sect1 xml:id="specvar">
      <title>Special variables</title>
    </sect1>
    <sect1 xml:id="datatypes">
      <title>Data types, finally we can have spaces in filenames!</title>
    </sect1>
    <sect1 xml:id="string">
      <title>String</title>
      <!-- common operations -->
    </sect1>
    <sect1 xml:id="array">
      <title>Array</title>
      <!-- common operations -->
      <!-- array append assignment top-level only -->
    </sect1>
    <sect1 xml:id="simpletypes">
      <title>Simple data types: number, boolean, nil</title>
      <!-- common operations -->
    </sect1>
    <sect1 xml:id="tree">
      <title>Tree</title>
      <!-- common operations -->
    </sect1>
    <sect1 xml:id="functiondelayeval">
      <title>Functions and delayed evaluation</title>
    </sect1>
    <sect1 xml:id="functionglobalscope">
      <title>Functions, global variables and scoping</title>
      <!-- calling one function from another function -->
      <!-- difference between functions and built-ins -->
    </sect1>
  </chapter>
  <chapter xml:id="commands">
    <title>How Stirmake executes its commands</title>
    <!-- tab, at-tab, at-at-tab -->
    <!-- the dangers of shell expansion -->
    <!-- shell can still be manually invoked -->
    <!-- build command and file size database -->
    <!-- move madness -->
    <!-- ignore -->
    <!-- noecho -->
    <!-- ismake and automatic make detection -->
  </chapter>
  <chapter xml:id="cleaning">
    <title>Automated cleaning with stirmake</title>
    <!-- distrule and disttgt -->
  </chapter>
  <chapter xml:id="conditional">
    <title>Conditional compilation</title>
  </chapter>
  </part>
  <part xml:id="part_stirmakelargescale">
  <title>Stirmake in large-scale systems</title>
  <chapter xml:id="multiproject">
    <title>Stirmake for entire project structures</title>
    <!-- including sub-projects -->
    <!-- invoking stirmake: smka, smkp, smkt -->
    <!-- controlling what to export with holey scopes -->
  </chapter>
  <chapter xml:id="oneprojectatatime">
    <title>Make revolution, one project at a time</title>
    <!-- Not everyone uses stirmake yet -->
    <!-- integration to jobserver and make autodetection -->
    <!-- backtick-equals, backtick-backtick-equals -->
    <!-- chomp -->
    <!-- getenv -->
    <!-- strwordlist -->
    <!-- recommendation for CC and CFLAGS support, both list of lists -->
    <!-- integration to subproject cleaning systems with clean hooks -->
    <!-- recdep and detouchrule/rectgtrule/mayberule -->
    <!-- make in same directory with mayberule -->
  </chapter>
  <chapter xml:id="scopingandsubdirectories">
    <title>Scoping and subdirectories</title>
    <!-- lexical vs dynamic: we support both -->
    <!-- holey scopes -->
    <!-- named scopes -->
    <sect1 xml:id="dirupdirdown">
      <title>Specifying library lists that work everywhere</title>
      <!-- introduce problem of specifying static dependencies -->
      <!-- @dirdown @dirup -->
    </sect1>
  </chapter>
  </part>
  <part xml:id="part_advancedprogramming">
  <title>Advanced stirmake programming</title>
  <chapter xml:id="programmingwithamyplan">
    <title>Programming Stirmake with Amyplan</title>
    <!-- abce and amyplan -->
    <!-- creating amyplan scripts -->
    <!-- lack of REPL due to being yacc-based -->
    <!-- constant strings and modifiable packet buffers -->
    <!-- TODO: memcpy with packet buffers, needs abce support -->
    <!-- io streams and interacting with them -->
    <!-- JSON -->
  </chapter>
  <chapter xml:id="advancedtricks">
    <title>Advanced tricks</title>
    <!-- pattern rules -->
    <!-- deponly for additional dependencies -->
    <!-- @order and @wait -->
    <!-- dynamically adding rules -->
    <!-- dynamically adding dependencies -->
    <!-- version conditionals and minimum version requirements, future b-ins -->
    <!-- finding gitmake version and version history -->
    <!-- hacking abce: need for all to be visible to abce at all times -->
  </chapter>
  </part>
</book>
